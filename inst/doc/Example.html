<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Bård Pedersen" />


<title>Functions for calculating the Nature Index</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Functions for calculating the Nature Index</h1>
<h3 class="subtitle"><em>Note to participants in output 4 of PDP1 under BG03 - IBBIS</em></h3>
<h4 class="author"><em>Bård Pedersen</em></h4>
<h4 class="date"><em>Norwegian Institute for Nature Research, May 26, 2016</em></h4>



<p>This document explains how to calculate the Nature index (NI) using the functions found in the r-script file <em>Simplified functions for calculating the Nature Index.R</em>. The document begins with describing the calculation of the index before explaining the structure of objects containing the necessary input data. Thereafter each function is given a short description. Finally, the calculation of NI is described and illustrated with examples.</p>
<div id="introduction-mathematical-framework" class="section level1">
<h1>Introduction: Mathematical framework</h1>
<div id="definition" class="section level2">
<h2>Definition</h2>
<p>The nature index is a weighted average of scaled indicator observations</p>
<span class="math display">\[\begin{equation}{NI}_{jkt} = \displaystyle\sum_{i=1}^nw_{ijk}S_{ikt}\end{equation}\]</span>
<p>where <span class="math inline">\(S_{ikt}, i=1,...,n\)</span> is the <span class="math inline">\(n\)</span> scaled indicator states included in the calculation. The weights <span class="math inline">\((w_{ijk})\)</span> must conform to <span class="math inline">\(\sum_{i=1}^nw_{ijk} = 1\)</span>.</p>
</div>
<div id="spatial-units" class="section level2">
<h2>Spatial units</h2>
<p>The Nature Index is calculated for a specified major habitat <span class="math inline">\((j)\)</span> in a defined area <span class="math inline">\((k\)</span>, here referred to as an NI-area<span class="math inline">\()\)</span> and for a particular year <span class="math inline">\((t)\)</span> from a set of indicator-observations.</p>
<p>Indicator observations are however collected from indicator-specific spatial units (here referred to as indicator-areas) that may have a different spatial extent than the NI-area. The spatial delineation of indicator areas may also vary among indicators.</p>
<p>That is, for each indicator there is a set of non-overlapping spatial units from which indicator observations are collected. However, each indicator-area and NI-area must consist of one or more basic spatial units. In the Norwegian implementation of the Nature index this basic spatial unit is the municipality.</p>
<p>Thus, in order to calculate the index, the delineation of each indicator-area and each NI-area must be provided. That is, each indicator- and NI-area must be specified in terms of the basic spatial units they consist of. Further, all indicator observations must be linked to the correct indicator area. See section Input data below.</p>
</div>
<div id="indicator-observations" class="section level2">
<h2>Indicator observations</h2>
<p>Indicator observations may be associated with errors and are therefore uncertain. Thus, in the context of the Nature Index, the indicator observations are specified as probability distributions where the dispersion of the distribution represents this uncertainty, and the central tendency of the distribution represents the size of the indicator value. Thus, each observation is regarded as a stochastic variable. This presupposes that all input values used to calculate the index are provided with an estimate of how uncertain the values are. This estimate is provided by each expert in terms of the interquartile distance in the distribution, while the central tendency is given as an expected value.</p>
<p>Elicitation is the term for the process that generates probability distributions for uncertain quantities based on experts’ knowledge and beliefs about them. In the context of the Nature Index, this is a two-step process. For all indicator values, experts estimate the distribution’s expected value and its lower and upper quartiles. The R-scripts for calculating NI presupposes that these three parameters are provided for all indicator observations included in the calculation of the nature index.</p>
<p>During the calculation of the index, a probability distribution is fitted from a number of model distributions for each indicator value. The fitting is based on a least squares criterion. All the indicators are supposed to be nonnegative variables with zero as the minimum value. Hence, the model distributions are non-negative, univariate distributions. These are truncated normal-, lognormal-, Weibull-, “zeroinflated” exponential -, and gamma distributions. The truncated normal distribution is left-truncated at zero. All model distributions thus have two parameters.</p>
</div>
<div id="scaling" class="section level2">
<h2>Scaling</h2>
<p>Scaling the indicator values to a common scale is done using nonlinear scaling functions (Figure 5.1). The scaling functions contain only one parameter, the socalled reference value <span class="math inline">\((Ref)\)</span>. Reference values are specified for each indicator area in which an indicator is observed. The scaling functions’ values are over the interval [0,1].</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAIAAACb4TnXAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAS00lEQVR4nO3da4wV5R3H8f/ColwWAbdJqRTSNKSlJoCENDUiJMX2DaQtJpIITWAXFKiAXFIDNlGxgEWp9KJAYeWyLPZFNSkRmlhSSJekpbiURjauWAw1JBsI5SoB9sJ6+uJMz5mdMzNnztn5zzwz5/t5NXsuM8/A/M5cnpnnX5XJZASAjn5xNwBIMwIGKCJggCICBigiYIAiAgYoImCAIgIGKCJggCICBigiYIAiAgYoImCAIgIGKCJggCICBigiYIAiAgYoImCAIgIGKCJggCICBigiYIAiAgYoImCAIgIGKCJggCICBigiYIAiAgYoImCAIgIGKCJggCICBigiYIAiAgYoImCAIgIGKCJggCICBigiYIAiAgYoImCAIgIGKCJggCICBigiYIAiAgYoImCAIgIGKCJggCICBigiYIAiAgYoImCAIgIGKCJggCICBigiYIAiAgYoImCAIgIGKCJggCICBigiYIAiAgYoImCAIgIGKCJggCICBigiYIAiAgYoImCAIgIGKKp2/F1VVeV4JZPJRNUYIG3yActGqzBOXq8DKKoqm5yqqir/CBEzoAxFcuX8dLEcmmz16tXHjh2LuxWIQXV19YEDB0aOHBnDou1/FN1NZTKZ5Gbs+PHjy5YtGz9+fNwNQdTmzJlz6dKlmAMWMDkJTVfWuHHjJk+eHHcrELVBgwbFtWgrYK7pyl1RTHSoKsvdu7J5s/zrX3G3I1YDB8rq1fLQQ3G3Q6TwMn2OPXJJOSw8ffr0hg0bvN5tbW09d+7cww8/HGWTovbyy+L9L1BBTp6Utra4GyHiEzC7pJx6jRo1avbs2V7vHjp06PPPP4+yPVH7xz9k06a4G2GGMWPiboElUMCSora21idgCxYsqK5O1fr2cvu2zJ8vd++KiEyZIitWxN2g+AwfLsYcp1gbnGMflYj9FXpZuVL+/W8RabvvvovPPjvd+4cmidrb21taWmbNmhV3Q0rGvYipcOiQNDRkJ5sff/zdv/411taE79SpU7t37467FeXIByy7E8ti95Ukly7JggXW9OzZ8p3vxNoa9NJrD5b5P8eHiJzRFi+W//5XRGTkSNm2Le7WoJciJ/3cgmi6piY5cMCa3rlTvvSlWFsDJ7+OZiFahjt/XpYvt6YXLpQf/EBEZs6cmb6+vkceeWTEiBFxt6Ic7lcRkQCZjNTXy40bIiJjx8pvfpN9ecyYMWOM6QUKS21t7aOPPhp3K8rhcpHD/wtFP4CIvPGGHD0qItK/v+zdK0OGxN0guHC5yOEVM+0LjI7l5i5pKi0u2T76SNassaZXr5YpU3LvtLW1Hc0GL0Xa29sP5E41E8WlH8weMzvXC4xhyc0/m6jcn7lXkNfdLfPmSUeHiMiECbJ+vf3N5ubmd999N56GqUluP5jnVcQoz8fsO8bCs0HOD502bpRTp0RE7rlH9u2Te++Nu0HwxJ0cSXPihGzcaE2vWycTJ8baGhRBwBLl9m2pq7Pu6J02LX8aBlMZcXe5/SAwO8Gdx+6ef17OnBERGTpU9u6Vfi6/j/SDGcWgbddx10joz1OXd1dKwIEifWZe3lsu3n9fZsyQ7Id/9ztZvDjQtyAyceLEpqamCRMmRL9oI/ZgWY7tLPbke129jOf2sWvX5KmnrHTNnEm6koJzMHf2dGVsXD8QhWeflfZ2EZHa2tyTKa7oBzOKyx7MsW1F2Bh3wfcYmUzm+vXrYS3RdaG5E0UJdnKYm1WfziT/8AfZv9+abmiQr3zF57PNzc2tra3Tp08vc1lGyvaDJfGBS5ex6R1nQbFfYwi+9KNHj/oMGRDicgu7v3Nd88FbG/SH48IFWbrUmp47Vx5/POD8YYLi52AJ6ud97LHHrl696vVuwIO6ko79/P9l7BEq80azTEbq6uTyZRGRMWN43CtxAp2DVeD9SkWTENEvzltvyeHDIiJVVbJrlwwbFsVCER6DriIKxZMczp6VVaus6aVL5XvfC/Il+sGM4gxYXAeEFE9y6umRujq5dUtE5JvflFdfDfg9ngczivvd9BE/J+Jzq36Cbqi3X2AsqvgPxy9/KX//u4jIgAHy9tsyeHAojUTE3M/Bcps740yVzRGhkuInH34oL71kTa9dK6UUrKAfzCjOgNkfc3TtYIW6jg6ZO1c6O0VEvv1tefHFkr7N82BGcTkHy06Efiugj9xBIOdgIiLr1lmFCwYNksZGSfFw3xWg+AOX0STN6wgqrmgVPSp2PdgL2N3s96vR3CybN1vTGzfKt74VuMkwkVkdzSbsqUq6phJyg2/elPp6+eILEZHp0yu6gENapKp8Ubh8VrloAl33UcUvz/70p/Kf/4iIjBghjY2uj3sVRT+YUTi+d2Efe0d656TondABd4Au3z10SHbutKZ/9Sv56ldLbXYW/WBGcbnZNzuR1v2Vz9ZfONKOz1fKu5fKM36XLsnChdb0E0/I/Pn+M0dSOA9Cctfl7dfrK5N/33fIC1u8WC5dEhEZOVK2b+/LnOgHM4rnUb4jaSnYodXU1DQ0NGS8uX4r4McKv1LCu/v3h1jAgX4wo+SLP2QnCreMFETLaOfPy7Jl1vT/CzggNfLFH7ITqT8HM0smIwsWFBZwQGoYcSdH5XrjDTlyRIQCDqllyp0clchewGHVKnsBh76gH8woge7kiKAdobhw4cL+/fu/yN4JUaC7u7urqyviJnlyFHDYsCGsGdMPZhTPUaUSlKucGzduXLlyxevdTCbT3d0dZXv8vPJKvoBDYyMFHNLKc1Qpx5FhIq7Ujxs3btOmTV7vbt26dYghJzkffJDfZb30kjz0UIjzbmtru3jxYsqGbWtvb29paUnisG1+d7vZ+8Eia1D63bkj8+fnCzisXRvu7OkHM4pfR7P9WNH83Vdi2As47NlT3h29SAqGbYvW++/Lb39rTb/2mnz967G2Bupc7kUkS1rsBRxmzKCAQyVwuYqYOxqszMfAFK1Y0auAg84PGf1gRinSD5bxHi0DpXnnHWlqsqYbGuSBB5SWQz+YUdyfB3M8GRVpi1Lp4kV55hlres4cCjhUDvfnwbg0HyZ7AYfRo7ULOPA8mFH8Bh4lZuHYtUv+/GcRkaoq2b1bhg9XXRr9YEYxuqM5DfH+9FNZudKafuaZgAUckBrF+8Ecd06hBI4CDq+9FneDEDXPq4iFFRz1GuGT3mQ/LPP66/K3v4lQwKFyeY4qJdFu067LSnYv3OnT+WHl16wpqYBDX9APZhTPJ5qjlMLeNkcBh1ypFH30gxnFlIFH7Wd6aYjZyy/LRx+JUMCh0pl1K3fs1y3DcexY/nrGhg0RF3CgH8woZgUsKxezuBtSlps3pa7OKuDw3e/mr9FHhX4wo5h76JLUA8XnnssXcNi3j8e9Kpy5AcsJfmJ2/Pjx5cuXe717586d69evh9myQn/6k+zYYU1v2VJ2AQekRvGRfWMXvEmTJk3akdu+C0ybNm3YsGEhNcrNlSvy9NPW9BNPSF2d4rKQEKka2XfgwIGTvbub+vXrp3te9/TTcuGCSAgFHPqCfjCjuPSDZbt3E520GLz9tvzxj9b0jh19LODQF/SDGcVz2LZY9mnm1GguzfnzsnSpNb1ggfzwh7G2BgYJerOv9oaeK5LkkIA+McMKONAPZhQjRpXKRct10ab3ib35Zq8CDjU18TaHfjCjMKpU33zySX7k0JUrwyrggNRw2YMl48DMBN3dMneu3L4tIjJ+vGzcGHeDYBz3jubChyxVz8F87qY3+vbfX/wiX8Bh3z4KOKCQ350c0T8PlqSriB98IOvXW9MvvhhuAYe+oB/MKJ7li7Ii3r7NjZODvYDD1Kny/PNxNyiPfjCjOM/B7NfKc69E3irj/exnVgGHmhrZu5c7euElUD8YGevl6FGTCzjQD2YUI/rBkuTaNZk3z3rca8YMWbIk7gY50Q9mFI5tSrRyZQQFHJAadDSX4p13ZN8+a/rNN/UKOCA13MsXkTEX9gIOTz4pTz4Za2uQDEU6mnloJW/RonwBh/ge9yqKfjCj+D3RTKjydu2SgwdFRKqqZNcu7QIOfUE/mFFS9URzV1dXa2ur17tfZC/9leHTT2XFCmv6Jz+R73+/zPmg8niO7JvEpJ04cWLVqlVe73Z0dFy9erXkmdoLOHzjG7J5cx8aGIW2traLFy9Onz497oaEqb29vaWlZdasWXE3pGSe9yImMWlTp049efKk17tDhw69//77S57pli1WAYf+/aWx0fwCDs3Nza2trSkLWLYfLFUByzE/V4pOn5YXXrCm166V1F08gDaXjmYeBrN0dcm8efkCDuvWxdweJJDnoDeOI8NkVxIqz7p18uGHIhRwQPmKPw9WoXuzY8fk1Vet6fXrIy7g0Bf0gxnF7yJH7tGVitt93bwp9fX5Ag7eVyYNRD+YUbib3s1zz8m5cyIUcEBfcbNvAXsBh9dfT1wBB54HM4r7qFK5iYoLm6OAQ319rK0pB8+DGaXIlbEUVk/2lyvg8OUvm3xHL5LCc9Ab+34sstbEPKrU73+fL+Cwc2eMBRyQGp79YD6vaIh/XMTz5/OPe9XXU8ABoQh0q5R2xnzmH1E3dyYjCxdaBRy+9jX59a8Vl6WMfjCjBLo7If1dYVu3yl/+IiLSv780Ncl998XdoPLRD2YUenhEPvlE1qyxpleskGT+R8JMRvSD+ZSbyNUN01p2d7f8+Mf5Ag6vvKK1oKjQD2YUU6qr2Mvt2XnVDQvNpk3yz3+KiNxzjzQ2pqCAA/1gRjGiukrES8lraZGf/9yafuEFmTQp0qWjAvQKWIw9YDHo7JSnnrIKOEyenD8NA8KTD5ix1wmDd4WdPXt2y5YtXoPbdHZ23s6ea2Xt3i2nT4uIDBokTU0yYEAorQXs8sO2eXXySty7suBLHzx48CTvw7yDBw+OHTvW/mlrYtOmBD3uVRT9YEbx7AezR87YnZvDqFGjFi1a5PXunj17eg16M3++DB8uAwbIjBlRNC4q9IMZpbI7mn/0o7hbgJQza5wJ7Zt9m5qampubc38eOXLkzJkzg40fia0kd+/e7enpuTf5/Q12PT09AwcOHD16dHlf/+yzzzqzgxdFLj+yb7zHhBHc7LtkyZKPP/742rVruVdaWlru3LlTW1vb95mb49atW3fv3h02bFjcDQlTR0dHZ2dnTU1NeV9/8MEHH4ipFI57qCK+p77ozJWWPmXKlCFDhhw+fDj0Ocdo+/btra2t27Zti7shYTp48GBDQ8N7770Xd0NKlj9EtN8klcLTLSAOvc7BvHKVziscgL4iFzmied7RZ2CCyhqwAKlTfEyOaNrhNcgp0UKimXWZnjghZXjgElBEwABFFR2w6urqAam7ib66uro6dYVgkrtSFX39/fLly/369Sun7KXBOjs7u7q6hg4dGndDwtTT03Pz5s3hBtee91LRAQO0VfQhIqCNgAGKCBigiIABiggYoIiAAYoIGKCIgAGKCBigiIABiggYoCiRdyiHItEj/LgWlyp1RWIcjsHrH99/CHe7pKxshQYsiQODO7huiMFXJMa1dv3H9/8fSe7KcoiISDm2dft4R9mJhP7eeanEPZjr/3GC/lMDttarfmLudQPXurCCcdJXthIDlkqODcjnz3h/UIqOvRmkeUlZWSFgCeU/vp2BuyYv9lzlXiy88uH4VoJWloAljNf2FHw7M2eLLLsmQYJWloClTe5SQdwN8RPWRXPzV5aApZAhOygv4e5VDF/ZSrxM77hUFftRRHDlHTIZtbJ9P7pL0MpKZQasopiwkUXGwJWt0EPEFBdDc+yfDVy7EEt8JGBlDWwTkBocIgKKCBigiIABiggYoIiAAYoIGKCIgAGKCBigiIABiggYoIiAAYoIGKCIgAGKCBigiIABiggYoIiAAYoIGKCIgAGKCBigiIABiggYoIiAAYoIGKCIgAGKCFhovIroRF9cp7wlhttOk0sKRYmAAYoIGKCoQqurhC5IMavstFc1kBBfD/Ix+1s+lcILX3esUdE2lDeH1CBgkSrc+rN/hvV6wMUVToe4LlHOwXwcIkaqpA3IZ4MLMh+frzveCt4q+xf7GIZUxqkQAQtB8ONDn28FOVgqfL2qqsp/KX1pf2HDvD7gs2/0X+vU4xDRCLkDP/t0kI3ecVLn+IDXW8E3cfv8vX4RvNrgw6d5KUPAtJTxUx0kWsHnrLqj6PuOqEL2YxwiRsHnSCn4r3juVz/49brCrwdpW9GPBb92Evz4MK17MwIWgsJjpLJ/4INfLpcSw+k124BfL+OtkmaS1h1aalcsev49TuX1Jvm/ngu217V7n/bY51B0G3BtfxltqKgesCwCBijiEBFQRMAARQQMUETAAEUEDFBEwABFBAxQRMAARQQMUETAAEUEDFBEwABFBAxQRMAARQQMUETAAEUEDFBEwABFBAxQRMAARQQMUETAAEUEDFBEwABF/wP8oVWkUlQREAAAAABJRU5ErkJggg==" width=".49\linewidth" /><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAIAAACb4TnXAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAUqElEQVR4nO3dfYwU5R0H8O+dRznhEPC0pSAX25AWbSAS+oKiNEINIoVirYlAAgeUlyLoQVNBUzkaoESwSH2B0isvB2iaagry0hQstAdVsIekcIAYKCUNFygFFBDuBe62f+ywO8zszM7uzm+eeWa/n/jH3L7Nb3G+O7PPb3aeglgsBiKSUai6AKIoY8CIBDFgRIIYMCJBDBiRIAaMSBADRiSIASMSxIARCWLAiAQxYESCGDAiQQwYkSAGjEgQA0YkiAEjEsSAEQliwIgEMWBEghgwIkEMGJEgBoxIEANGJIgBIxLEgBEJYsCIBDFgRIIYMCJBDBiRIAaMSBADRiSIASMSxIARCWLAiAQxYESCGDAiQQwYkSAGjEgQA0YkiAEjEsSAEQliwIgEMWBEghgwIkEMGJEgBoxIEANGJIgBIxLEgBEJYsCIBDFgRIIYMCJBDBiRIAaMSBADRiSIASMSxIARCWLAiAQxYESCGDAiQQwYkSAGjEgQA0YkiAEjEsSAEQliwIgEMWBEghgwIkEMGJEgBoxIEANGJIgBIxLEgBEJYsCIBBVZ/i4oKLDcEovFgiqGKGqSAYtHyx4np9uJKK2CeHIKCgrcI8SYEWUhTa6sj06XwzCbOXPmrl27VFdBChQVFW3cuLFLly4KVm3+I+1uKhaL6ZuxPXv2TJs2rVevXqoLoaCNHDny7NmzigPmMTmapiuuZ8+effv2VV0FBe3WW29VtWojYCnTlRhR1DpUjhoaMG8ejh9XXYeA7t1RWYnbblNdB9mG6RPMkdPlsPDgwYPz5893ureuru7EiRP9+vUz/v7Nb7BwYUCVBe9f/8LGjaqLIOeAmeny1atbt25PPvmk071btmy5dOlS8u+ysiBqUuXdd7F6NcaNU11HvvMUMF2Ulpa6BGz8+PFFRab3+8QT+OADnDoVRGVB+uMf8fvfA0BFBR5+GHffrbie/GZscJZ9lBb7Kx/cf7/qCvx3pEePM3v3Djx5EpcuYdQo7N6NW25RXVSu6uvra2trR4wYobqQjPFcxKip2bv3nW9+E23aAMCePVi8WHVFPti/f/+qVatUV5GNZMDiO7G4vNh9Rdidd+KFF4zlykocOKC0mrx20x4sdoPlQYycfn7+c3z72wDQ3IxRo9DYqLqgPJXmEJE7NF0VFaG6GvEG65EjqKxUXVCecms0I6ot5kgbOnSo0evr2RMLF6KiAgBefhmPPYbvfldtbVl74IEHOnfurLqKbBh7sPgXMLWlkC/Kysr69Olj/PHMMxg8GABaWzFuHC5fVlhYLkpLSx988EHVVWQjxSCH+xOYQ50UFGDlSsQ/+//9b8ycqbqgvJNikMMpZtLfxyzrTQxpCq0uqo4cObJz587k3926YelSY/l3v8OWLUqqylF9ff1GPc/8SjHIYY6ZWcoBRr8kXj+eqMSfPHbNVE1NzTvvvHPTTWPGIHGCy/jx+O9/g68qR1Hog1nEbOSKMO8Y7ec9MmM+WLYM8V9D/e9/mDxZdTV5hGdy5Ic77sCaNYh/Tr37LtatU11QvmDA8sbgwZgwwViePh3/+Y/SavJFKM6mNx8Wxhfy8cxjnyT7YHZLl+Jvf8Px47h4EePG4b33UKjHJ6z2fTDlEsMq8SxJnBj5+eefe3xk2tHLtCOcHsc/JYZJb+qDWbRvjzVrjJPrd+7Ea6/5u2o5UeiDKWcZSpEYXJk4cWLax/i4xadNqV8rykD//slu2OzZOHRIQQ35JEQB04X52ltOITEf37q8CARORrP2wezmzUPv3gDQ2IixY3Htmr8FSIhUH8zc+wq+IDvvlcRisU+dJV7NfV0+VHyjGF8ek6kUfTCLtm3x1lsoLgaA/fuxYIHvNfhO3z5YimvTWz59lY8xeF/7zp07XS4Z4Avz7ittg87yxTLli6jxjW+gshLPPw8ACxZgyBB85zvKiom09IeIGvV5Bw0adMEZgKqqKqQ7bMt0u/c4mJHR44Pw3HMYMAAArl9HeTmuXlVdUDR5+g6mUcbCxn44YLldmcJCrFmDDh0A4OhRY29GfgtFHyzBHmP1G6KJfRfndBBoZj7BMnGLXJFufTCLr3wFixdjyhQAeO01DBmCRx+VKywX0emDqdpZmc8nNvN9rMVp9E/0e5ElkxKrSHDrg9lNnoyhQwEgFsOPf4wLF+QKy0Wk+mASm7U7l1P1eUK9uKoqlJYCQH09nn1WdTVRk/o7WGJz9/10Cn057eLcG2Lm59qXJaTvg1l8+cuoqjKW16/HH/4gUVWOotMHM3fAgvmtSvDskfB+fFiQStqnmNcL4Yyl74PZPf44Ro82lqdOxenTvleVI337YCm+g5m//ARzbOZyUBqZ/Weidaa6EAdvvGFcrP/8eZSXI7R16ib9Dy6DSZplXeZD0zBslPZdugUc9kvuPbcQ6dgRq1YZPxjbvj150Ei58dRoRlAfvSk3XKEV4ebelMS6Uo7LB3OgmI1Bg/D008byzJk4dkxpNRERqemLwinluIhcujLog9m99BLeew+ffIIrV1Bejl27QjJxRHT6YGTnZReX6cCJl7HH7GTWB7No1w5vvmlMHPHBB3j5ZR8Ly0V0+mBBjm2oZd7Efd85e/8HDN0/dd++ydOm5szhxBE5CsUoYlR52en5LuM+mN2LL4Zt4ojo9MESLEmLwBewkpISyy1OQymWGz0Ot5gflsVT/JJNH8zCMnHE3Ll+1JUT7ftgLvurkAyUU6B69sQvf2ksL16Mmhql1WgsOfkDjwzpJs88g4EDAe0njlCL38HIQWEhqquTE0f89KeqC9KSYx/M3g/lgaIWcuqDWdx1F155BeXlAFBVheHD8f3v+/PKGdK3D5a+0axRrk6fPr1+/frW1taU9167dq25uTngkoJXVlZWFj+r0Bdjx2LrVrz9NgBMmIC6Onzxi769uGf69sFSBEzu1CFpFy9ePH/+vNO9sVjsmg6XKAudZcuwezfOnMHZs5g8GRs2qC5IK/Zz/5wGqe0nCuqlpKSkqqpKdRXiDh8+vGPHDp9fdNOmGGD8t26dzy/uwalTpzZs2JD103v37n3gwAEf6/HO7VSp+CM41KEXH/pgdsOGJSeOmDYt+IkjtO+D2cVunJAaC/kPmSgYv/41evQAgIsXMX48fzDmES/bRt6YJ47YsUOjiSPUCstVpUgD/ftjxgxjedYsHD6stBo9pBhFjJlOqIvGWYh5xc8+mN38+di+HQcPorERY8Zg717jty3C9O2DpTlEjEXoZN88kdPvwdJq2xbV1fjCFwBg//7k+YrC9O2Dpf49mPmW+FhigCVRuN13HyorjeX58/GPfyitJuxSn4vIoXl9+fB7sLRmz05OHDF2LBoaZFcXvd+DMWb6EumDWRQWYvXqICeOiGAfDCGIGeMdXl/9KhYtMpZffRV//rPSasLL62XbuK2T1eTJeOwx4MbEETfmECUzx4CZr/4J4TM57NcbTayXP0sLr4ICThyRVoopZBPLQQ4eplwX2wNZkO2DWXTtiqoq/PCHALBuHYYNg8wUvtHpg5lPBA6sCA6o+Ei2D2b3+OMYOdJYnjoVZ85IrCQ6fTBVlA+oUPaWLUP37gBw7hwnjrAIS8DiGLPcBdEHs+jUKTlxxLZtWLnS9zVErQ+mViJmqgvRUhB9MLvvfQ9TpxrLFRU4ftzfl49mH0wtnqKlmUWL8PWvAzAmjmhpUV1QKHiaXUUt732CPXv2TJ8+3enehoaGzz77zM/KyCw+ccT99+PaNbz/Pn71Kzz3nOqa1DMCFuZrs3kvqU+fPitWrHC6d8CAAR07dvSpKEqlb1/MmoX58wFgzhw8+ih691Zdk2JGwGKRuApicXFx3759ne4tLCzMh+91gfbB7CorsW0bamvR1IRRo7BvH4qLc3/VSPXBYGpM5cMWGTFB98EszBNHHD6MX/zCl1eNTh8scfJEot0cZNJSni1FmrnnHuMoEcCiRdi1S2k1ioVljubE76YtGLNMKeiD2VVU4OGHAaC1FeXluU8cEfE+mHRXKhGtlKtmTywjavpgFoWFWLs2OXHEz36W4+tFpw/GrZn8cdddWLLEWF6xAlu3Kq1GmRR7MB6YkT/Ky/GjHxnLEyfCedqACEt/yYDEtyO5IlwiHcDaSdDy5ejSBQBOn8bEiaqrUcDtTI7gfw9mzxijlSnFfTCLO+7AihX4wQ8AYMMGvPkmRo/O4mWi0weD7bfMQbKPIgZcQAQo7oPZDR+O8eON5aefzm7iiKj1wcwbN7+MUa7yeOIIT30wZkwjoeiDWZSU3DRxxBtvZPoC7INRWISiD2bXvz8qKozlWbPwyScZPTs6fTAiKQsWoFcvALh6FaNHIz+m82WjmYLSti3WrjUmjvjoIyxcqLqgILDRTAG67z7MmWMsz5uXDxNHpO6DJbpSWv88LD+Fqw9m9/zz2LYNu3cbE0fs32/8tsWV9n2wlI0v9qN0FLo+mEVhIdasQUkJABw9ihde8PIkfftgkfpFc3Nzc11dndO9ra2tQRZDjuITR8SvQvXqqxg2DAMHqq5JivUQUeukffjhhzMSkwjbNDY2XrhwIch6lDhy5MiZM2cGhnyTnTIFW7bgT39CayvGjEFdHVyPAOvr62tra0eMGBFYgX5xPBdRx6Q99NBD+/btc7q3Q4cOt99+e5D1KFFTU1NXVxf2gMUnjujdG+fPo74eFRWornZ5eLwPpmPAPJ3Jwa9h5L+uXfH668by2rV4+22l1UhxPNk3+FIo7zz1FJ56ylgWmzhCLceTfS3jiowciVi+PDlxxKRJqqvxX/rfgzFaegl7H8yiUyesXInBgxGLYfNmrFyJCRPsj9K+D2aXOGcqmKtKkV/C3geze+QR/OQnxvKzz6acOELfPhjPpqcQWLwYX/saEMGJI3iyb9SE8fdgabVrh+pq4wdj77+fvBzVDZH6PVjiaJBh01FIfw+WVr9+mD3bWH7xRRw8aL4zsr8HSwwn8jsYiZs7F9/6FgA0NWHMGDQ3qy7IB+n7YEF2mXlt+rxmnjjiwAHMnau4Hj849sHMtwRQB69NTwBwzz2YN89YfumlCEwckX6Gy/hWLroTc3n9RC+Ox6geadYHs5sxA1u34q9/RWsrxo3DP/+JDh0i2Acz42iHRvTrg1kUFmLVKtx2GwCcOBGfhzbifTCiQN19N5YuNZY1nzgiFH0wXpveR1r2wezGjcMTTwBALIaJE+sPHYpUHyz4oQX7dBPmYY8gK9Gdrn0wu+XL8aUvAcDp0/snTYpUHyzg2VUs6+W1QAgA7rwTv/2tsbxnD+rrlVaTpZtGEc1n94In+JJyw4dj1Ci89RYAHDqEyZM9PatTJ0yYYJzcqFoyYKH9qmOJvYtjx44tWbLE6eI2TU1NV69e9bk4kvb669i1C6dOobk5uUNL6y9/wUcfSZbllRGwlOkKydU4vK+9Xbt2LiPUmzdv7hGf4yPStO+DWXTujFWrHhgypHNGp9h7uNZiMBwbzebIhXbnZtGtW7dJzr+KXb16dT5c9KasrKysrEx1Fb565JHSv//9wZtP/3Vzyy3GlH8hkP5MDgRyMgeRm379oOdu2VPAAmPvDfib6nXr1tXU1CT+3LFjx9GjR9u1a+fjKpS7fv16S0tL27ZtVRfip5aWluLi4u7xq3dk7uTJk01NTf6W5FHyyr5qjwmdRjK8j3CkNWXKlI8//vjTTz9N3FJbW9vQ0FBaWpr7i4fHlStXrl+/3rFjR9WF+KmxsbGpqakkfsHtzN17771du3b1tySPUofKHjDRyKV9caG19+/fv3379tu3b/f9lRVavnx5XV3dsmXLVBfip82bN1dVVW3atEl1IRlLHiKaT5Li1y0iX9z0HcwpVxzhIMpOmkEOH78CubBcIi74AoiEpAlYYFu200VOGS3SWriG6Rknihj+4JJIEANGJCivA1ZUVNSmTRvVVfisqKioqChcR/650/dN5fX4+7lz5woLCyN2BnBTU1Nzc3OHDh1UF+KnlpaWy5cvd+rUSXUhGcvrgBFJy+tDRCJpDBiRIAaMSBADRiSIASMSxIARCWLAiAQxYESCGDAiQQwYkSAGjEiQlmco+0LrK/yknFwq0zei8HIMTv/47pdwN9PlzeZpwHS8MLhFyg3R+xtR+K5T/uO7/x/R983yEJECZdnWzdc7ii9o+nnnJB/3YCn/H2v0P9VjteYjK/PjE7eH8F3bZzDW/c3mY8AiybIBufyp9gMl7bU3vZSny5sFA6Yp9+vbhXDX5MScq8SN9pEPy7M0erMMmGactifv21l4tsis5yTQ6M0yYFGTGCpQXYgbvwbNw/9mGbAICskOyom/e5WQv9l8HKa3DFUpP4rwLrtDplC92dyP7jR6s8jPgOWVMGxkgQnhm83TQ8QIT4Zm2T+H8N35OMWHBm82hDURRQYPEYkEMWBEghgwIkEMGJEgBoxIEANGJIgBIxLEgBEJYsCIBDFgRIIYMCJBDBiRIAaMSBADRiSIASMSxIARCWLAiAQxYESCGDAiQQwYkSAGjEgQA0YkiAEjEsSAEQliwIgEMWC+cZpEJ/jJdbJbo791hnlKoSAxYESCGDAiQXk6u4rvvExmFV92mg3Ex9u9PMx8l8tM4fbbLe8obQ3ZvUJkMGCBsm/98T/9ut3j6uzLPr6XIF8h/HiIGKiMNiCXDc7L67g83XKX96rMT8wxDJGMkx0D5gPvx4cuz/JysGS/vaCgwH0tudRvL8zpAS77Rvd3HXk8RAyFxIGfednLRm/5Umd5gNNd3jdx8+s7fSI41eDCpbyIYcCkZPFR7SVa3l9ZdEeR+44oT/ZjPEQMgsuRkvdP8cSnvvfxOvvTvdSW9mHex068Hx9GdW/GgPnAfoyU9Qe89+FyZBhOp5f1+PQs7sroRaK6Q4vsGwuee8cpu26S++2JYDuN3bvUY36FtNtAyvqzqCGvOmBxDBiRIB4iEgliwIgEMWBEghgwIkEMGJEgBoxIEANGJIgBIxLEgBEJYsCIBDFgRIIYMCJBDBiRIAaMSBADRiSIASMSxIARCWLAiAQxYESCGDAiQQwYkSAGjEgQA0YkiAEjEvR/I1wn3dcFDVkAAAAASUVORK5CYII=" width=".49\linewidth" /> <strong>Figure 1:</strong> <em>The scaling models LOW and MAX</em></p>
<p>There are two types of scaling functions, LOW and MAX (Figure 1). The choice of scaling function is determined by whether the indicator correlates positively or negatively with the aspect of biodiversity that the indicator represents. The LOW model is used when there is a positive correlation between the indicator and biodiversity. This holds true for most indicators. The MAX model is used when there is a negative correlation between the indicator and biodiversity. This applies only to certain indirect indicators that represent a negative effect that the measured indicator has on other components of biodiversity.</p>
</div>
<div id="weights" class="section level2">
<h2>Weights</h2>
<p>The nature index is a weighted average. In a weighted average, the state values used to calculate the average are weighted in relation to each other. Some indicator observations are given more weight than others. There are two motives for doing this in the context of the Nature Index. One motive is to correct for biases in the data from which the index is calculated. The second motive relates to the meaning of the index.</p>
<p>The current R-scripts calculate weights according to the Norwegian implementation of the Nature Index. However, the weighting system might be modified to better accord with the Bulgarian dataset and the purposes of the Bulgarian implementation. The Norwegian weighting system is described below.</p>
<p>The weights assigned to individual indicator values for the calculation of the Norwegian Nature Index for a basic spatial unit (i.e. a municipality) take into account the indicators’ specificity / fidelity to the respective major ecosystem and the indicators’ ecological function. The weights can be written as a product of two factors, a trophic weight <span class="math inline">\((w^{trophic})\)</span> and a fidelity weight <span class="math inline">\((w^{fidelity})\)</span>.</p>
<p>The indicators’ <strong>fidelities</strong> <span class="math inline">\((\varphi_{ij})\)</span> to the various major habitats are determined by the individual expert based on the degree to which the underlying data for the indicator reflect the state of one or more major ecosystems. An indicator’s total fidelity is <span class="math inline">\(100\%\)</span>, i.e. <span class="math inline">\(\sum_{j=1}^p\varphi_{ij} = 100\%\)</span>. Many indicators belong to only one of the major ecosystems; for example, mussels are only an indicator for the coast bottom major ecosystem and have a fidelity of 100% to the coast bottom, with a fidelity of 0% to the other major ecosystems. Conversely, marine fish species will often belong to two or more of the marine major ecosystems, ocean pelagic and ocean bottom, coast pelagic and coast bottom. In these situations (unless ecosystem-specific data are available), the fidelity is divided over several major ecosystems based on the extent to which the data for the indicators are affected by conditions in the different systems. The effect of this is that indicators that belong to several major ecosystems will be included in the calculation of the Nature Index for all of these systems. But their weight is then reduced in each of these calculations compared with indicators that have a 100% fidelity to one system. In some cases, ecosystem-specific data is available for a species, and then separate indicators with 100% fidelity can be used. The <strong>fidelity weight</strong> of an indicator belonging to trophic group <span class="math inline">\(g\)</span> is given by</p>
<span class="math display">\[\begin{equation}w_{ijk}^{fidelity} = \frac{\varphi_{ij}} {\displaystyle\sum_{m \in g}\varphi_{mj}}\end{equation}\]</span>
<p>where the sum in the denominator is over all indicators within the trophic group observed in the geographical unit. The same holds for key indicators that are treated as a separate group in this context.</p>
<p><strong>Trophic weight</strong>, <span class="math inline">\((w^{trophic})\)</span>, is equal to <span class="math inline">\(\frac{1}{2}\)</span> for the key indicators and equal to <span class="math inline">\(\frac{1}{2r_{jk}}\)</span> for other indicators, when observations of key indicators from municipality <span class="math inline">\(k\)</span> is included in the calculation. When key indicators are lacking in <span class="math inline">\(k\)</span>, the trophic weight for other indicators are <span class="math inline">\(\frac{1}{r_{jk}}\)</span>. <span class="math inline">\(r_{jk}\)</span> is the number of functional groups represented by indicator observations in the municipality <span class="math inline">\(k\)</span>.</p>
<p>The product of an indicator observation’s fidelity weight and trophic weight is the <strong>total weight</strong> given to the observation in a calculation of the nature index for a municipality <span class="math inline">\(k\)</span>,</p>
<span class="math display">\[\begin{equation}w_{ijk}^{p} = w_{ijk}^{fidelity}*w_{ijk}^{trophic}\end{equation}\]</span>
<p>and the nature index for major habitat <span class="math inline">\(j\)</span> in the municipality at time <span class="math inline">\(t\)</span> is</p>
<span class="math display">\[\begin{equation}{NI}_{jkt} = \displaystyle\sum_{i=1}^nw_{ijk}^{p}S_{ikt}\end{equation}\]</span>
<p>where the sum is over all indicators recorded in the municipality with <span class="math inline">\(\varphi_{ij} &gt; 0\)</span> and <span class="math inline">\(\displaystyle\sum_{i=1}^nw_{ijk}^{p}=1\)</span>.</p>
<p>The consequences of these allocations are first, that the sum of the weights <span class="math inline">\(w_{ijk}^{p}\)</span> for key indicators is <span class="math inline">\(\frac{1}{2}\)</span>. So key indicators weigh 50% in the Nature Index for a municipality where observations of key indicators have been included in the calculation. Second, the different trophic groups represented in the municipality are weighted equally, regardless of the number of indicators represented within each group.</p>
<p>Municipalities are the basic spatial units for terrestrial major habitats and freshwater in the Norwegian implementation the Nature Index. However, in practice, aggregated indices for larger NI-areas <span class="math inline">\((K)\)</span> are calculated as weighted averages of municipal index values, e.g. for country parts or the whole country:</p>
<span class="math display">\[\begin{equation}{NI}_{jKt} = \displaystyle\sum_{k \in K}w_{jk}^{area}{NI}_{jkt} = \displaystyle\sum_{k \in K}\displaystyle\sum_{i=1}^nw_{jk}^{area}w_{ijk}^{p}S_{ikt}\end{equation}\]</span>
<p>where <span class="math inline">\(w_{jk}^{area}\)</span> are the <strong>area weights</strong>, <span class="math inline">\(w_{jk}^{area} = \frac{a_{jk}} {\displaystyle\sum_{q \in K}a_{jq}}\)</span>, <span class="math inline">\(a_{jk}\)</span> is the area that major ecosystem <span class="math inline">\(j\)</span> covers in municipality <span class="math inline">\(k\)</span>, and <span class="math inline">\(\displaystyle\sum_{k \in K}w_{jk}^{area} = 1\)</span>.</p>
</div>
<div id="calculating-the-nature-index" class="section level2">
<h2>Calculating the Nature Index</h2>
<p>Since the Nature Index is calculated from indicator observations that are considered stochastic variables, the index itself is also a stochastic variable with an associated probability distribution. Parametric bootstrapping is used to simulate this distribution from the distributions of indicator values. An observation from the index’s distribution is generated by randomly drawing one observation from each of the distributions of indicator observations used in the calculation. The Nature Index value is then calculated based on this. The index’s distribution is simulated by repeating this procedure 1000 times, for example. Normally, the median of the simulated distribution is given as a point estimate for the Nature Index, while the 95% confidence interval given by the 2.5% and 97.5% quantiles of the distribution is used as a measure of uncertainty for the index value.</p>
<p>There are different opinions on whether uncertainties in reference values should be accounted for in the calculation of the nature index. On one hand reference values may be considered as fixed parameters that have been decided on the basis of the ecological framework described in Pedersen <em>et al.</em> (2016)<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> rather than estimated from the framework. On the other hand, reference values could be viewed as uncertain estimates derived from or modelled on the basis of the framework. In the Norwegian implementation uncertainties in reference values are not accounted for in the calculations. This is because uncertainties in many reference values have not been estimated.</p>
</div>
<div id="functions" class="section level2">
<h2>Functions</h2>
<p><em>Simplified functions for calculating the Nature Index.R</em> contains the following functions:</p>
<table style="width:94%;">
<colgroup>
<col width="20%"></col>
<col width="73%"></col>
</colgroup>
<thead>
<tr class="header">
<th align="left">Function name</th>
<th align="left">Operation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">elicitate.fct</td>
<td align="left">Fits probability distributions to indicator observations</td>
</tr>
<tr class="even">
<td align="left">sampleobs.fct</td>
<td align="left">Samples from the indicator observation distributions</td>
</tr>
<tr class="odd">
<td align="left">scaleobs.fct</td>
<td align="left">Scales samples from indicator observations according to chosen scaling model</td>
</tr>
<tr class="even">
<td align="left">munweights.fct</td>
<td align="left">Calculates the product: trophic weights * fidelity weights</td>
</tr>
<tr class="odd">
<td align="left">areaweights.fct</td>
<td align="left">Calculates area weights</td>
</tr>
<tr class="even">
<td align="left">NIcalculation.fct</td>
<td align="left">Calculates a sample of the Nature Index from samples of scaled indicator observations and area-, trophic-, and fidelity weights</td>
</tr>
<tr class="odd">
<td align="left">summary.NIresults</td>
<td align="left">Provides point estimates of the Nature Index together with 95% confidence intervals</td>
</tr>
</tbody>
</table>
<p>Several of these functions call other functions that are also included in the file.</p>
<p></p>
</div>
</div>
<div id="input-data" class="section level1">
<h1>Input data</h1>
<p>In order to use the above functions to calculate NI for a set of <span class="math inline">\(N.reg\)</span> NI-areas, from a set of in total <span class="math inline">\(N.obs\)</span> indicator observations and reference values, over <span class="math inline">\(N.years\)</span> years, for <span class="math inline">\(N.ind\)</span> indicators from altogether <span class="math inline">\(N.omr = N.obs/(N.years+1)\)</span> indicator areas involving <span class="math inline">\(N.kom\)</span> basic spatial units, the following input data should be provided:</p>
<ol style="list-style-type: decimal">
<li>A data frame with indicator observations <strong>together</strong> with reference values</li>
<li>A data frame with indicator data</li>
<li>A data frame with basic spatial unit data</li>
<li>A data frame relating indicator areas to indicators</li>
<li>A data frame descrbing indicator areas in terms of basic spatial units</li>
</ol>
<div id="indicator-observations-and-reference-values" class="section level2">
<h2>Indicator observations and reference values</h2>
<p>The data frame should contain at least the following variables (variable names may be different)</p>
<table>
<colgroup>
<col width="23%"></col>
<col width="19%"></col>
<col width="57%"></col>
</colgroup>
<thead>
<tr class="header">
<th align="left">Variable</th>
<th align="center">Type</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">ValueID</td>
<td align="center">integer</td>
<td align="left">vector of indicator observation- and reference value IDs</td>
</tr>
<tr class="even">
<td align="left">Expected.value</td>
<td align="center">double</td>
<td align="left">vector of the indicator observations’ and reference values’ expected values</td>
</tr>
<tr class="odd">
<td align="left">Lower</td>
<td align="center">double</td>
<td align="left">vector of the observations’ 0.25 (lower) quartiles</td>
</tr>
<tr class="even">
<td align="left">Upper</td>
<td align="center">double</td>
<td align="left">vector of the observations’ 0.75 (upper) quartiles</td>
</tr>
<tr class="odd">
<td align="left">IndicatorID</td>
<td align="center">integer</td>
<td align="left">vector of corresponding indicator IDs</td>
</tr>
<tr class="even">
<td align="left">IndicatorareaID</td>
<td align="center">integer</td>
<td align="left">vector of corresponding indicator area IDs</td>
</tr>
<tr class="odd">
<td align="left">ReferenceYearID</td>
<td align="center">integer</td>
<td align="left">vector of corresponding IDs for observation years / reference values</td>
</tr>
</tbody>
</table>
<p>Thus each indicator observation consists of the expected value together with the upper and lower quartiles. Each observation should have a unique ID and be linked to the correct indicator and indicator area through their IDs.</p>
<p>The last variable should signal whether the entry is a reference value or indicator observation. If it is an indicator observation the year or a yearID should be entered. If it is a reference value, an integer code, e.g. <span class="math inline">\(0\)</span>, should be entered.</p>
</div>
<div id="indicators" class="section level2">
<h2>Indicators</h2>
<p>The data frame should contain at least the following variables (variable names may be changed)</p>
<table>
<colgroup>
<col width="23%"></col>
<col width="19%"></col>
<col width="57%"></col>
</colgroup>
<thead>
<tr class="header">
<th align="left">Variable</th>
<th align="center">Type</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">IndicatorID</td>
<td align="center">integer</td>
<td align="left">vector of indicator IDs</td>
</tr>
<tr class="even">
<td align="left">Indicator_name</td>
<td align="center">character</td>
<td align="left">vector of the names of indicators</td>
</tr>
<tr class="odd">
<td align="left">Scalingmodel</td>
<td align="center">integer</td>
<td align="left">vector of scaling model IDs, 1 = LOW and 2 = MAX</td>
</tr>
<tr class="even">
<td align="left">TrophicgroupID</td>
<td align="center">integer</td>
<td align="left">vector of trophic group IDs that the corresponding indicator belongs to</td>
</tr>
<tr class="odd">
<td align="left">Key.indicators</td>
<td align="center">logical</td>
<td align="left">vector indicating whether corresponding indicator is a key indicator or not</td>
</tr>
<tr class="even">
<td align="left">Fidelity</td>
<td align="center">double</td>
<td align="left">vector of indicator fidelities to the major habitat in question</td>
</tr>
</tbody>
</table>
<p>The data frame should contain complete data for all indicators included in the calculation. The code for scaling models should be 1 for LOW and 2 for MAX. Key indicators should be signalled with TRUE, non-key indicators with FALSE. Fidelity should be gven as a number between 0 and 1.</p>
</div>
<div id="basic-spatial-units-and-ni-areas" class="section level2">
<h2>Basic spatial units and NI-areas</h2>
<p>The data frame should contain at least the following variables (variable names may be changed)</p>
<table>
<colgroup>
<col width="23%"></col>
<col width="19%"></col>
<col width="57%"></col>
</colgroup>
<thead>
<tr class="header">
<th align="left">Variable</th>
<th align="center">Type</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Basicsunit</td>
<td align="center">character</td>
<td align="left">vector of names of basic spatial units</td>
</tr>
<tr class="even">
<td align="left">NIarea</td>
<td align="center">character</td>
<td align="left">vector of NI area names that the corresponding basic spatial units are part of</td>
</tr>
<tr class="odd">
<td align="left">Area</td>
<td align="center">double</td>
<td align="left">vector containing the areas of basic spatial units</td>
</tr>
</tbody>
</table>
<p>An NI-area consists of those basic spatial units that share the same name in the variable NIarea. Basic spatial units may be grouped into NI-areas in several different ways by adding new “NIarea”-variables to the data frame</p>
</div>
<div id="to-relate-indicator-areas-to-indicators" class="section level2">
<h2>To relate indicator areas to indicators</h2>
<p>The data frame should contain the following variables (variable names may be changed)</p>
<table>
<thead>
<tr class="header">
<th align="left">Variable</th>
<th align="center">Type</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">IndicatorareaID</td>
<td align="center">integer</td>
<td align="left">vector of unique indicator area IDs</td>
</tr>
<tr class="even">
<td align="left">Indicator_name</td>
<td align="center">character</td>
<td align="left">vector of indicator names</td>
</tr>
</tbody>
</table>
<p>All indicator areas that are defined for the same indicator should have identical entries in Indicator_name.</p>
</div>
<div id="to-describe-indicator-areas-in-terms-of-basic-spatial-units" class="section level2">
<h2>To describe indicator areas in terms of basic spatial units</h2>
<p>The data frame should contain at least the following variables (variable names may be changed)</p>
<table>
<thead>
<tr class="header">
<th align="left">Variable</th>
<th align="center">Type</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">IndicatorareaID</td>
<td align="center">integer</td>
<td align="left">vector of indicator area IDs</td>
</tr>
<tr class="even">
<td align="left">Basicsunit</td>
<td align="center">character</td>
<td align="left">vector of names of basic spatial units</td>
</tr>
</tbody>
</table>
<p>The ID of an indicator area consisting of <span class="math inline">\(n\)</span> basic spatial units should be entered <span class="math inline">\(n\)</span> times in IndicatorareaID, while the names of the <span class="math inline">\(n\)</span> basic spatial units should be entered in the corresponding entries of Basicsunit.</p>
<p></p>
</div>
</div>
<div id="test-data-set" class="section level1">
<h1>Test data set</h1>
<p>An example data set is found in the package NIcalc:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">require</span>(NIcalc)

<span class="kw">data</span>(BSunits, Indic, Indicator.area, Indicator.area.ind, Observations)
<span class="kw">ls</span>()</code></pre></div>
<pre><code>## [1] &quot;BSunits&quot;            &quot;Indic&quot;              &quot;Indicator.area&quot;    
## [4] &quot;Indicator.area.ind&quot; &quot;Observations&quot;</code></pre>
<p>The test data consist of 236 observations for <span class="math inline">\(N.ind=33\)</span> indicators in <span class="math inline">\(N.omr=59\)</span> indicator areas over <span class="math inline">\(N.years=4\)</span> years, together with reference values for each of the indicator areas. So <span class="math inline">\(N.obs=295\)</span>. Years are coded <span class="math inline">\(2,3,4,8\)</span>, and reference values <span class="math inline">\(0\)</span>. The following table contains the first and last six entries of the data.frame Observations:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">xtable</span>(<span class="kw">rbind</span>(<span class="kw">head</span>(Observations), <span class="kw">tail</span>(Observations))))</code></pre></div>

<p>All indicators are scaled with the LOW model. They are all indicators for the same major habitat (which is unspecified), but with varying fidelity. Non-key indicators are grouped in <span class="math inline">\(5\)</span> functional groups coded <span class="math inline">\(1,2,5,8,9\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">xtable</span>(<span class="kw">rbind</span>(<span class="kw">head</span>(Indic), <span class="kw">tail</span>(Indic))))</code></pre></div>

<p>There are only <span class="math inline">\(N.kom=4\)</span> basic spatial units, “Mun1” to “Mun4”, and most, but not all indicator areas consist of a single basic spatial unit. There are <span class="math inline">\(2\)</span> different predefined sets of NI-areas with <span class="math inline">\(N.reg = 1, 2\)</span> respectively, in addition to the set of basic spatial units.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">xtable</span>(BSunits))</code></pre></div>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">xtable</span>(<span class="kw">rbind</span>(<span class="kw">head</span>(Indicator.area.ind), <span class="kw">tail</span>(Indicator.area.ind))))</code></pre></div>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">xtable</span>(<span class="kw">rbind</span>(<span class="kw">head</span>(Indicator.area), <span class="kw">tail</span>(Indicator.area))))</code></pre></div>

<p></p>
</div>
<div id="required-libraries" class="section level1">
<h1>Required libraries</h1>
<p>The functions elicitation.fct() and sampleobs.fct() requires the R-libraries</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(MASS)
<span class="kw">library</span>(gamlss.dist)
<span class="kw">library</span>(truncnorm)
<span class="kw">require</span>(msm)</code></pre></div>
<pre><code>## Loading required package: msm</code></pre>
</div>
<div id="set-of-functions" class="section level1">
<h1>Set of functions</h1>
<p>The set of functions are incorporated in the NIcalc package.</p>
<div id="elicitate.fct" class="section level2">
<h2>elicitate.fct</h2>
<p>elicitate.fct fits probability distributions to a set of indicator observations by selecting for each observation the distribution among a predetermined set of model distribution families that best fits the observation. The function presumes that indicator observations are each given as three parameters of a continuous probability distribution: expected value and the lower- and upper quartiles. The predetermined set of continuous distributions is {Truncated Normal, Lognormal, Weibull, Gamma, zero-inflated exponential}</p>
<p>Input arguments:</p>
<table>
<colgroup>
<col width="18%"></col>
<col width="15%"></col>
<col width="15%"></col>
<col width="17%"></col>
<col width="32%"></col>
</colgroup>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Object type</th>
<th align="left">Mode</th>
<th align="left">Dim</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Expected.value</td>
<td align="left">vector</td>
<td align="left">double</td>
<td align="left"><span class="math inline">\(N.obs\)</span></td>
<td align="left">indicator observations’ expected values</td>
</tr>
<tr class="even">
<td align="left">Lower</td>
<td align="left">vector</td>
<td align="left">double</td>
<td align="left"><span class="math inline">\(N.obs\)</span></td>
<td align="left">indicator observations’ 0.25-quantiles (lower quartiles)</td>
</tr>
<tr class="odd">
<td align="left">Upper</td>
<td align="left">vector</td>
<td align="left">double</td>
<td align="left"><span class="math inline">\(N.obs\)</span></td>
<td align="left">indicator observations’ 0.75-quantiles (upper quartiles)</td>
</tr>
</tbody>
</table>
<p>Expected.value, Lower and Upper should be of equal length.<br />
For indicator observations and reference values with no uncertainty, Expected.value, Lower, and Upper should be equal.<br />
Expected.value, Lower and Upper should be nonnegative. Negative values in an element of any of the these vectors are interpreted as missing value and the corresponding output elements are set to NA. Also, if one of Expected.value, Lower and Upper is NA, all corresponding output elements are set to NA.</p>
<p></p>
<p>Output:</p>
<table>
<colgroup>
<col width="18%"></col>
<col width="15%"></col>
<col width="15%"></col>
<col width="17%"></col>
<col width="32%"></col>
</colgroup>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Object type</th>
<th align="left">Mode</th>
<th align="left">Dim</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">elicitation.results</td>
<td align="left">data.frame</td>
<td align="left"></td>
<td align="left"><em>N.obs x 4</em></td>
<td align="left">consisting of the following vectors</td>
</tr>
<tr class="even">
<td align="left">[[1]] $FK_DistID</td>
<td align="left">vector</td>
<td align="left">character</td>
<td align="left"><span class="math inline">\(N.obs\)</span></td>
<td align="left">names of fitted model distributions</td>
</tr>
<tr class="odd">
<td align="left">[[2]] $mu</td>
<td align="left">vector</td>
<td align="left">double</td>
<td align="left"><span class="math inline">\(N.obs\)</span></td>
<td align="left">first parameter of fitted model distributions</td>
</tr>
<tr class="even">
<td align="left">[[3]] $sig</td>
<td align="left">vector</td>
<td align="left">double</td>
<td align="left"><span class="math inline">\(N.obs\)</span></td>
<td align="left">second parameter of fitted model distributions</td>
</tr>
<tr class="odd">
<td align="left">[[4]] $ssq</td>
<td align="left">vector</td>
<td align="left">double</td>
<td align="left"><span class="math inline">\(N.obs\)</span></td>
<td align="left">sum of squared deviations between observed parameters and those of the fitted model distributions.</td>
</tr>
</tbody>
</table>
<p>Functions called:</p>
<p>estim.fct() local function in present collection<br />
estimlight.fct() local function in present collection</p>
<p>elicitation.fct first try to fit a model distribution with a call to the function estim.fct. If this results in an error, it calls estimlight.fct instead. These functions again each calls a series of other local functions included in <em>Simplified functions for calculating the Nature Index.R</em>, which again make use of routines in the MASS, gamlss.dist and truncnorm packages. Descriptions of all local functions are found in the file.</p>
<div id="examples" class="section level3">
<h3>Examples:</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">elicitate</span>(<span class="dt">expected.value =</span> Observations$Expected.value[<span class="dv">1</span>:<span class="dv">10</span>], <span class="dt">lower =</span> Observations$Lower[<span class="dv">1</span>:<span class="dv">10</span>], 
    <span class="dt">upper =</span> Observations$Upper[<span class="dv">1</span>:<span class="dv">10</span>])</code></pre></div>
<pre><code>##      FK_DistID         mu          sig          ssq
## 1  TruncNormal  19.290161 1.079512e+01 5.646243e-02
## 2  TruncNormal  12.904372 1.880387e+01 8.556086e-01
## 3  TruncNormal -48.054273 2.695735e+01 1.225590e+00
## 4  TruncNormal -48.054273 2.695735e+01 1.225590e+00
## 5  TruncNormal   6.452186 9.401937e+00 2.139022e-01
## 6  TruncNormal   6.452186 9.401937e+00 2.139022e-01
## 7      Weibull 100.000000 1.366650e+09 6.669306e-15
## 8  TruncNormal  99.719655 3.721850e+01 2.563655e-02
## 9    LogNormal   2.924586 3.172087e-01 1.906000e-02
## 10   LogNormal   2.924917 3.172494e-01 2.382124e-02</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Observations2 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(Observations, <span class="kw">elicitate</span>(<span class="dt">expected.value =</span> Observations$Expected.value, 
    <span class="dt">lower =</span> Observations$Lower, <span class="dt">upper =</span> Observations$Upper)[, <span class="dv">1</span>:<span class="dv">3</span>])
<span class="kw">head</span>(Observations2)</code></pre></div>
<pre><code>##   ValueID IndicatorID Expected.value Lower Upper ReferenceYearID
## 1      96         101             20    13    27               2
## 2      97         101             20    10    30               2
## 3      99         101             10     3    16               3
## 4     101         101             10     3    16               4
## 5     103         101             10     5    15               3
## 6     104         101             10     5    15               4
##   IndicatorareaID   FK_DistID         mu       sig
## 1            1523 TruncNormal  19.290161 10.795121
## 2            1524 TruncNormal  12.904372 18.803874
## 3            1523 TruncNormal -48.054273 26.957346
## 4            1523 TruncNormal -48.054273 26.957346
## 5            1524 TruncNormal   6.452186  9.401937
## 6            1524 TruncNormal   6.452186  9.401937</code></pre>
<p></p>
</div>
</div>
<div id="sampleobs.fct" class="section level2">
<h2>sampleobs.fct</h2>
<p>sampleobs.fct returns nsim random draws from a set of distributions given by the vector DistID and the parameter vectors mu and sig. The function presumes that the set only includes the truncated normal-, lognormal-, weibull-, gamma-, zero-inflated exponential, poisson-, negative binomial-, and zero-inflated poisson distributions. The lower bound in the truncated normal distribution is always zero, while the upper bound is infinity. With these restrictions all theoretical distributions have two parameters, except the poisson with only one parameter. Alternatively, if distrib == “NoBoot”, the function returns nsim copies of the observation’s expected value. The function does not handle missing values (NAs).</p>
<p>Input arguments:</p>
<table>
<colgroup>
<col width="18%"></col>
<col width="15%"></col>
<col width="15%"></col>
<col width="17%"></col>
<col width="32%"></col>
</colgroup>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Object type</th>
<th align="left">Mode</th>
<th align="left">Dim</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">ValueID</td>
<td align="left">vector</td>
<td align="left">integer</td>
<td align="left"><span class="math inline">\(N.obs\)</span></td>
<td align="left">indicator observation IDs</td>
</tr>
<tr class="even">
<td align="left">DistID</td>
<td align="left">vector</td>
<td align="left">character</td>
<td align="left"><span class="math inline">\(N.obs\)</span></td>
<td align="left">distribution families names or “NoBoot” (when copy obs)</td>
</tr>
<tr class="odd">
<td align="left">mu</td>
<td align="left">vector</td>
<td align="left">double</td>
<td align="left"><span class="math inline">\(N.obs\)</span></td>
<td align="left">vector of parameter 1 of model distributions</td>
</tr>
<tr class="even">
<td align="left">sig</td>
<td align="left">vector</td>
<td align="left">double</td>
<td align="left"><span class="math inline">\(N.obs\)</span></td>
<td align="left">vector of parameter 2 of model distributions</td>
</tr>
<tr class="odd">
<td align="left">Value</td>
<td align="left">vector</td>
<td align="left">double</td>
<td align="left"><span class="math inline">\(N.obs\)</span></td>
<td align="left">vector of observed expected value to be copied if distrib == “NoBoot”.</td>
</tr>
<tr class="even">
<td align="left">nsim</td>
<td align="left">vector</td>
<td align="left">integer</td>
<td align="left"><span class="math inline">\(1\)</span></td>
<td align="left">number of draws (simulations)</td>
</tr>
</tbody>
</table>
<p>Allowed names of distribution families are “TruncNormal”, “LogNormal”, “Weibull”, “ZIExponential”, “Gamma”, “Poisson”, “NegBinom”, “ZIP”, “NoBoot”</p>
<p>Output:</p>
<table>
<colgroup>
<col width="18%"></col>
<col width="15%"></col>
<col width="15%"></col>
<col width="17%"></col>
<col width="32%"></col>
</colgroup>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Object type</th>
<th align="left">Mode</th>
<th align="left">Dim</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">bootmat</td>
<td align="left">matrix</td>
<td align="left">double</td>
<td align="left"><em>N.obs x nsim</em></td>
<td align="left">random draws from specified (by DistID, mu and sig) models or <span class="math inline">\(nsim\)</span> copies of Value</td>
</tr>
</tbody>
</table>
<p>Functions called:</p>
<p>rtnorm - random generation function in the truncnorm package.<br />
rLOGNO, rWEI, rGA, rPO, rNBII, rZIP - random generation functions in the gamlss.dist package.<br />
runif and rexp - random generation functions from the stats package.</p>
<div id="examples-1" class="section level3">
<h3>Examples:</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">samplebootmat</span>(<span class="dt">ValueID =</span> Observations2$ValueID, <span class="dt">Value =</span> Observations2$Expected.value, 
    <span class="dt">RefobsID =</span> Observations2$ReferenceYearID, <span class="dt">DistID =</span> Observations2$FK_DistID, 
    <span class="dt">mu =</span> Observations2$mu, <span class="dt">sig =</span> Observations2$sig, <span class="dt">nsim =</span> <span class="dv">5</span>)[<span class="dv">1</span>:<span class="dv">10</span>, ]</code></pre></div>
<pre><code>##            [,1]       [,2]       [,3]       [,4]        [,5]
## 96    23.598524  19.700430   6.985116  17.796443  24.3861158
## 97     9.798696   4.211620   5.159527  37.102531  53.8582317
## 99    11.730463   3.054970   7.162858   3.713662   1.2157028
## 101   13.766988  12.564105   3.853642   2.679117   7.8311482
## 103   17.296198   2.241136  13.805646  13.210373   3.4576058
## 104   13.782359  14.166192   1.855725  14.581869   0.5168019
## 107  100.000000 100.000000 100.000000 100.000000 100.0000000
## 111  100.000000 100.000000 100.000000 100.000000 100.0000000
## 1343  14.216488  12.219279  13.782834  16.820487  21.2224552
## 1344  19.434662  14.088867  13.440234  13.383942  24.5426463</code></pre>
<p><br />
In order to base the calculation of NI on fixed reference values (i.e. to ignore uncertainties in them), the corresponding DistIDs should be set to “NoBoot”<br />
</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Alt_DistID &lt;-<span class="st"> </span>Observations2$FK_DistID
Alt_DistID[Observations2$ReferenceYearID ==<span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> &quot;NoBoot&quot;</span>

<span class="kw">samplebootmat</span>(<span class="dt">ValueID =</span> Observations2$ValueID, <span class="dt">Value =</span> Observations2$Expected.value, 
    <span class="dt">RefobsID =</span> Observations2$ReferenceYearID, <span class="dt">DistID =</span> Alt_DistID, <span class="dt">mu =</span> Observations2$mu, 
    <span class="dt">sig =</span> Observations2$sig, <span class="dt">nsim =</span> <span class="dv">5</span>)[<span class="dv">1</span>:<span class="dv">10</span>, ]</code></pre></div>
<pre><code>##            [,1]       [,2]       [,3]        [,4]       [,5]
## 96    35.291125  25.348012  24.432412  25.4034968  22.543988
## 97    22.147954  14.998720  51.976828  17.8119472  14.137458
## 99    16.777161   5.135845   5.259845  14.7206002   9.168302
## 101    4.940831  19.778286   3.534698   6.4299606   6.509348
## 103   11.102824  15.005156  15.432937   0.4644145   1.109501
## 104   11.574063  14.582415  16.685556  11.6408271  10.721706
## 107  100.000000 100.000000 100.000000 100.0000000 100.000000
## 111  100.000000 100.000000 100.000000 100.0000000 100.000000
## 1343  20.434134  24.818864  15.543624  17.0322567  14.515814
## 1344  34.509200  30.490933  31.421867  24.7164552  13.004491</code></pre>
<p>NI is calculated for one year at a time. To include observations from year 2 only:<br />
</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Observationsyear2 &lt;-<span class="st"> </span>Observations2[Observations2$ReferenceYearID %in%<span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">2</span>), 
    ]
Alt_DistIDyear2 &lt;-<span class="st"> </span>Alt_DistID[Observations2$ReferenceYearID %in%<span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">2</span>)]

bootmatyear2 &lt;-<span class="st"> </span><span class="kw">samplebootmat</span>(<span class="dt">ValueID =</span> Observationsyear2$ValueID, <span class="dt">Value =</span> Observationsyear2$Expected.value, 
    <span class="dt">RefobsID =</span> Observationsyear2$ReferenceYearID, <span class="dt">DistID =</span> Alt_DistIDyear2, 
    <span class="dt">mu =</span> Observationsyear2$mu, <span class="dt">sig =</span> Observationsyear2$sig, <span class="dt">nsim =</span> <span class="dv">1000</span>)
bootmatyear2[<span class="dv">1</span>:<span class="dv">10</span>, <span class="dv">1</span>:<span class="dv">5</span>]</code></pre></div>
<pre><code>##           [,1]       [,2]       [,3]       [,4]      [,5]
## 96    16.31124  16.046786  19.851174  17.847536  28.87416
## 97    20.54430   3.109299   8.767885   5.224293  57.89914
## 107  100.00000 100.000000 100.000000 100.000000 100.00000
## 111  100.00000 100.000000 100.000000 100.000000 100.00000
## 1345  40.00000  40.000000  40.000000  40.000000  40.00000
## 1346  40.00000  40.000000  40.000000  40.000000  40.00000
## 1349  42.28917  62.862525  35.280961  48.539733  36.35558
## 1350  50.56031  46.118026  30.573105  50.983606  51.44763
## 1357  85.00000  85.000000  85.000000  85.000000  85.00000
## 1358  85.00000  85.000000  85.000000  85.000000  85.00000</code></pre>
<p></p>
</div>
</div>
<div id="scaleobs.fct" class="section level2">
<h2>scaleobs.fct</h2>
<p>scaleobs.fct scales a set of indicator observations according to chosen scaling model (LOW or MAX) and associated reference values. Each indicator observation should be entered either as nsim random draws from distributions fitted to the original observations (that were provided as expected values and upper and lower quartiles), or as nsim repetitions of the original expected values provided by experts. In the same way, reference values should be entered either as nsim random draws from distributions fitted to the original reference values, or as nsim repetitions of the original expected values.</p>
<p>Reference values and indicator observations should be entered together in the same matrix bootmat. Furter a vector with codes identifying reference values from indicator observations and of length equal to the number of indicator observations and reference values should be entered. Vectors of the same length containing the observations/reference values area IDs and indicator IDs should also be entered.</p>
<p>Scaling models are specific for each indicator. They should be entered as a vector of scaling model codes where <span class="math inline">\(1 = LOW\)</span> and <span class="math inline">\(2 = MAX\)</span>, together with a vector of associated indicator IDs of the same length.</p>
<p>Input arguments:</p>
<table>
<colgroup>
<col width="18%"></col>
<col width="15%"></col>
<col width="15%"></col>
<col width="17%"></col>
<col width="32%"></col>
</colgroup>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Object type</th>
<th align="left">Mode</th>
<th align="left">Dim</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">ValueID</td>
<td align="left">vector</td>
<td align="left">integer</td>
<td align="left"><span class="math inline">\(N.obs\)</span></td>
<td align="left">indicator observation IDs</td>
</tr>
<tr class="even">
<td align="left">FK_OmraadeID</td>
<td align="left">vector</td>
<td align="left">integer</td>
<td align="left"><span class="math inline">\(N.obs\)</span></td>
<td align="left">indicator area IDs</td>
</tr>
<tr class="odd">
<td align="left">FK_IndicatorID</td>
<td align="left">vector</td>
<td align="left">integer</td>
<td align="left"><span class="math inline">\(N.obs\)</span></td>
<td align="left">indicator IDs</td>
</tr>
<tr class="even">
<td align="left">FK_RefAarID</td>
<td align="left">vector</td>
<td align="left">integer</td>
<td align="left"><span class="math inline">\(N.obs\)</span></td>
<td align="left">IDs for observation years / reference values</td>
</tr>
<tr class="odd">
<td align="left">nsim</td>
<td align="left">vector</td>
<td align="left">integer</td>
<td align="left"><span class="math inline">\(1\)</span></td>
<td align="left">number of draws (simulations) in the estimation of NI</td>
</tr>
<tr class="even">
<td align="left">bootmat</td>
<td align="left">matrix</td>
<td align="left">double</td>
<td align="left"><em>N.obs x nsim</em></td>
<td align="left">random draws from fitted distributions and/or copies of expected values</td>
</tr>
<tr class="odd">
<td align="left">ref.value.code</td>
<td align="left">vector</td>
<td align="left">integer</td>
<td align="left"><span class="math inline">\(1\)</span></td>
<td align="left">code for reference values used in FK_RefAarID, default <span class="math inline">\(= 0\)</span></td>
</tr>
<tr class="even">
<td align="left">IndicatorID</td>
<td align="left">vector</td>
<td align="left">integer</td>
<td align="left"><span class="math inline">\(N.ind\)</span></td>
<td align="left">unique indicator IDs</td>
</tr>
<tr class="odd">
<td align="left">FK_Scalingmodel</td>
<td align="left">vector</td>
<td align="left">integer</td>
<td align="left"><span class="math inline">\(N.ind\)</span></td>
<td align="left">scaling model IDs, <span class="math inline">\(1 = LOW\)</span> and <span class="math inline">\(2 = MAX\)</span></td>
</tr>
</tbody>
</table>
<p>Output:</p>
<table>
<colgroup>
<col width="18%"></col>
<col width="15%"></col>
<col width="15%"></col>
<col width="17%"></col>
<col width="32%"></col>
</colgroup>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Object type</th>
<th align="left">Mode</th>
<th align="left">Dim</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">scaled.bootmat</td>
<td align="left">matrix</td>
<td align="left">double</td>
<td align="left"><em>N.obs x nsim</em></td>
<td align="left">scaled draws from fitted distributions and/or scaled copies of expected values</td>
</tr>
</tbody>
</table>
<p>Note that scaleobs.fct scaled.bootmat is of the same dimension as bootmat. This means that scaled.bootmat contains nsim draws of scaled reference values which all are equal to 1. These must be removed from scaled.bootmat before using NIcalculation.fct to calculate random draws of the nature index.</p>
<p>Further, if the input bootmat matrix contains indicator observations for several years, so will the scaled.bootmat. However, the index is calculated for one year, so the output matrix scaled.bootmat must be split accordingly into a set of matrices, where each matrix contains draws of scaled indicator observations for one single year only.</p>
<div id="example" class="section level3">
<h3>Example:</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">scaled.bootmatyear2 &lt;-<span class="st"> </span><span class="kw">scaleobs</span>(<span class="dt">ValueID =</span> Observationsyear2$ValueID, <span class="dt">FK_OmraadeID =</span> Observationsyear2$IndicatorareaID, 
    <span class="dt">FK_IndicatorID =</span> Observationsyear2$IndicatorID, <span class="dt">FK_RefAarID =</span> Observationsyear2$ReferenceYearID, 
    <span class="dt">nsim =</span> <span class="dv">1000</span>, <span class="dt">bootmat =</span> bootmatyear2, <span class="dt">ref.value.code =</span> <span class="dv">0</span>, <span class="dt">IndicatorID =</span> Indic$IndicatorID, 
    <span class="dt">FK_Scalingmodel =</span> Indic$Scalingmodel)
scaled.bootmatyear2[<span class="dv">1</span>:<span class="dv">9</span>, <span class="dv">1</span>:<span class="dv">5</span>]</code></pre></div>
<pre><code>##           [,1]       [,2]       [,3]       [,4]      [,5]
## 96   0.1631124 0.16046786 0.19851174 0.17847536 0.2887416
## 97   0.2054430 0.03109299 0.08767885 0.05224293 0.5789914
## 107  1.0000000 1.00000000 1.00000000 1.00000000 1.0000000
## 111  1.0000000 1.00000000 1.00000000 1.00000000 1.0000000
## 1345 1.0000000 1.00000000 1.00000000 1.00000000 1.0000000
## 1346 1.0000000 1.00000000 1.00000000 1.00000000 1.0000000
## 1349 1.0000000 1.00000000 0.88202402 1.00000000 0.9088896
## 1350 1.0000000 1.00000000 0.76432762 1.00000000 1.0000000
## 1357 1.0000000 1.00000000 1.00000000 1.00000000 1.0000000</code></pre>
<p>To remove reference values from the output matrix scaled.bootmatyear2<br />
</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">scaled.bootmatyear2only &lt;-<span class="st"> </span>scaled.bootmatyear2[Observationsyear2$ReferenceYearID !=<span class="st"> </span>
<span class="st">    </span><span class="dv">0</span>, ]
scaled.bootmatyear2only[<span class="dv">1</span>:<span class="dv">9</span>, <span class="dv">1</span>:<span class="dv">5</span>]</code></pre></div>
<pre><code>##            [,1]       [,2]       [,3]       [,4]      [,5]
## 96    0.1631124 0.16046786 0.19851174 0.17847536 0.2887416
## 97    0.2054430 0.03109299 0.08767885 0.05224293 0.5789914
## 1349  1.0000000 1.00000000 0.88202402 1.00000000 0.9088896
## 1350  1.0000000 1.00000000 0.76432762 1.00000000 1.0000000
## 1863  0.1402931 0.47355877 0.87636578 0.58109445 0.6248448
## 10246 0.5611543 0.69876346 0.50927036 0.56968888 0.4055612
## 10264 0.6969493 0.71067966 0.59452694 0.61639485 0.7010231
## 10265 0.6579784 0.57684883 0.52152486 0.70969197 0.6927260
## 11349 0.9931251 0.43269091 1.00000000 0.76005986 0.7767076</code></pre>
<p>Now scaled.bootmatyear2only includes one observation per indicator area.<br />
</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dim</span>(scaled.bootmatyear2only)</code></pre></div>
<pre><code>## [1]   59 1000</code></pre>
<p>However, to keep track of which observation in scaled.bootmatyear2 corresponds to the various indicator areas we may want to create a new data frame with indicator observations corresponding to scaled.bootmatyear2<br />
</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Observationsyear2only &lt;-<span class="st"> </span>Observationsyear2[Observationsyear2$ReferenceYearID !=<span class="st"> </span>
<span class="st">    </span><span class="dv">0</span>, ]
<span class="kw">dim</span>(Observationsyear2only)</code></pre></div>
<pre><code>## [1] 59 10</code></pre>
</div>
</div>
<div id="areaweights.fct" class="section level2">
<h2>areaweights.fct</h2>
<p>areaweights.fct calculates relevant area weights <span class="math inline">\(w_{jk}^{area}\)</span> for chosen spatial resolution of the NI output. I.e. areaweights.fct calculates <span class="math inline">\(w_{jk}^{area}\)</span> for a set of aggregated, nonoverlapping, spatial units each consisting of one to many basic spatial units (municipalities). In the Norwegian implementation <span class="math inline">\(w^{area}\)</span> are weights based on the area the major habitat in question covers in each basic spatial unit. An alternative is to use the total area of the spatial unit, etc.</p>
<p><span class="math inline">\(w^{area}\)</span> is the relevant municipality area divided by the corresponding total area of the aggregate. Municipalities outside the aggregate receive weights equal zero</p>
<p>Area weights are relevant when NI is calculated for aggregates of basic spatial units.</p>
<p>Note that the weights are stored in a three-dimensional array to be included in the calculation of the nature index in a subsequent call to NIcalculation.fct. In the array weights are repeated for each indicator included in the current calculation of NI. This in order to simplify the coding of NIcalculation.fct.</p>
<p>Input arguments:</p>
<table>
<colgroup>
<col width="18%"></col>
<col width="15%"></col>
<col width="15%"></col>
<col width="17%"></col>
<col width="32%"></col>
</colgroup>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Object type</th>
<th align="left">Mode</th>
<th align="left">Dim</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Municipalities</td>
<td align="left">vector</td>
<td align="left">character</td>
<td align="left"><span class="math inline">\(N.kom\)</span></td>
<td align="left">names of all basic spatial units included in the calculation</td>
</tr>
<tr class="even">
<td align="left">Regions</td>
<td align="left">vector</td>
<td align="left">character</td>
<td align="left"><span class="math inline">\(N.kom\)</span></td>
<td align="left">names of aggregated spatial units that the corresponding municipality is a part of.</td>
</tr>
<tr class="odd">
<td align="left">Area.municipality</td>
<td align="left">vector</td>
<td align="left">double</td>
<td align="left"><span class="math inline">\(N.kom\)</span></td>
<td align="left">relevant basic spatial unit areas</td>
</tr>
<tr class="even">
<td align="left">Indicators</td>
<td align="left">vector</td>
<td align="left">character</td>
<td align="left"><span class="math inline">\(N.ind\)</span></td>
<td align="left">names of all indicators included in the calculation</td>
</tr>
</tbody>
</table>
<p>Output:</p>
<table>
<colgroup>
<col width="18%"></col>
<col width="15%"></col>
<col width="15%"></col>
<col width="17%"></col>
<col width="32%"></col>
</colgroup>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Object type</th>
<th align="left">Mode</th>
<th align="left">Dim</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Weights.reg.area</td>
<td align="left">array</td>
<td align="left">double</td>
<td align="left"><em>N.kom x N.ind x N.reg</em></td>
<td align="left"><span class="math inline">\(N.ind\)</span> copies of area weights for each NI area.</td>
</tr>
</tbody>
</table>
<div id="examples-2" class="section level3">
<h3>Examples:</h3>
<p>To calculate area weights for “All area”</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">areaweights1 &lt;-<span class="st"> </span><span class="kw">areaweights</span>(<span class="dt">Municipalities =</span> BSunits$Basicunit, <span class="dt">Regions =</span> BSunits$NIarea1, 
    <span class="dt">Area.municipality =</span> BSunits$Area, <span class="dt">Indicators =</span> Indic$Indicator_name)
areaweights1[, <span class="dv">1</span>:<span class="dv">6</span>, ]</code></pre></div>
<pre><code>##            Ind 1      Ind 2      Ind 3      Ind 4      Ind 5      Ind 6
## Mun 1 0.28708586 0.28708586 0.28708586 0.28708586 0.28708586 0.28708586
## Mun 2 0.56156202 0.56156202 0.56156202 0.56156202 0.56156202 0.56156202
## Mun 3 0.12625807 0.12625807 0.12625807 0.12625807 0.12625807 0.12625807
## Mun 4 0.02509405 0.02509405 0.02509405 0.02509405 0.02509405 0.02509405</code></pre>
<p></p>
<p>To calculate area weights for “Part 1” and “Part2”<br />
</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">areaweights2 &lt;-<span class="st"> </span><span class="kw">areaweights</span>(<span class="dt">Municipalities =</span> BSunits$Basicunit, <span class="dt">Regions =</span> BSunits$NIarea2, 
    <span class="dt">Area.municipality =</span> BSunits$Area, <span class="dt">Indicators =</span> Indic$Indicator_name)
areaweights2[, <span class="dv">1</span>:<span class="dv">6</span>, ]</code></pre></div>
<pre><code>## , , Part 1
## 
##           Ind 1     Ind 2     Ind 3     Ind 4     Ind 5     Ind 6
## Mun 1 0.6945448 0.6945448 0.6945448 0.6945448 0.6945448 0.6945448
## Mun 2 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000
## Mun 3 0.3054552 0.3054552 0.3054552 0.3054552 0.3054552 0.3054552
## Mun 4 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000
## 
## , , Part 2
## 
##            Ind 1      Ind 2      Ind 3      Ind 4      Ind 5      Ind 6
## Mun 1 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000
## Mun 2 0.95722528 0.95722528 0.95722528 0.95722528 0.95722528 0.95722528
## Mun 3 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000
## Mun 4 0.04277472 0.04277472 0.04277472 0.04277472 0.04277472 0.04277472</code></pre>
<p>To check if weights sum to 1<br />
</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">colSums</span>(areaweights2)[<span class="dv">1</span>:<span class="dv">6</span>, ]</code></pre></div>
<pre><code>##       Part 1 Part 2
## Ind 1      1      1
## Ind 2      1      1
## Ind 3      1      1
## Ind 4      1      1
## Ind 5      1      1
## Ind 6      1      1</code></pre>
<p>If you want to give equal weights to all basic spatial units in the calculation of NI, one could do as follows:<br />
</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">areaweights</span>(<span class="dt">Municipalities =</span> BSunits$Basicunit, <span class="dt">Regions =</span> BSunits$NIarea2, <span class="dt">Area.municipality =</span> BSunits$Area/BSunits$Area, 
    <span class="dt">Indicators =</span> Indic$Indicator_name)[, <span class="dv">1</span>:<span class="dv">6</span>, ]</code></pre></div>
<pre><code>## , , Part 1
## 
##       Ind 1 Ind 2 Ind 3 Ind 4 Ind 5 Ind 6
## Mun 1   0.5   0.5   0.5   0.5   0.5   0.5
## Mun 2   0.0   0.0   0.0   0.0   0.0   0.0
## Mun 3   0.5   0.5   0.5   0.5   0.5   0.5
## Mun 4   0.0   0.0   0.0   0.0   0.0   0.0
## 
## , , Part 2
## 
##       Ind 1 Ind 2 Ind 3 Ind 4 Ind 5 Ind 6
## Mun 1   0.0   0.0   0.0   0.0   0.0   0.0
## Mun 2   0.5   0.5   0.5   0.5   0.5   0.5
## Mun 3   0.0   0.0   0.0   0.0   0.0   0.0
## Mun 4   0.5   0.5   0.5   0.5   0.5   0.5</code></pre>
</div>
</div>
<div id="munweights.fct" class="section level2">
<h2>munweights.fct</h2>
<p>munweights.fct calculates fidelity weights <span class="math inline">\((w^{fidelity})\)</span>, trophic weights <span class="math inline">\((w^{trophic})\)</span> and their product <span class="math inline">\(w^{p}\)</span> for each combination of municipality and indicator. <span class="math inline">\(w^{p}=0\)</span> for indicators not observed in a municipality.</p>
<p>Input arguments:</p>
<table>
<colgroup>
<col width="18%"></col>
<col width="15%"></col>
<col width="15%"></col>
<col width="17%"></col>
<col width="32%"></col>
</colgroup>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Object type</th>
<th align="left">Mode</th>
<th align="left">Dim</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Municipalities</td>
<td align="left">vector</td>
<td align="left">character</td>
<td align="left"><span class="math inline">\(N.kom\)</span></td>
<td align="left">names of all basic spatial units included in the calculation</td>
</tr>
<tr class="even">
<td align="left">Indicators</td>
<td align="left">vector</td>
<td align="left">character</td>
<td align="left"><span class="math inline">\(N.ind\)</span></td>
<td align="left">names of all indicators included in the calculation</td>
</tr>
<tr class="odd">
<td align="left">FK_TrophicgroupID</td>
<td align="left">vector</td>
<td align="left">integer</td>
<td align="left"><span class="math inline">\(N.ind\)</span></td>
<td align="left">trophic group IDs that the corresponding indicator belongs to</td>
</tr>
<tr class="even">
<td align="left">Key.indicators</td>
<td align="left">vector</td>
<td align="left">logical</td>
<td align="left"><span class="math inline">\(N.ind\)</span></td>
<td align="left">key indicator or not</td>
</tr>
<tr class="odd">
<td align="left">Fidelity</td>
<td align="left">vector</td>
<td align="left">double</td>
<td align="left"><span class="math inline">\(N.ind\)</span></td>
<td align="left">indicator fidelities to the major habitat in question</td>
</tr>
<tr class="even">
<td align="left">Areaind.Name</td>
<td align="left">vector</td>
<td align="left">integer</td>
<td align="left"><span class="math inline">\(N.omr\)</span></td>
<td align="left">unique indicator area IDs for <strong>all</strong> areas included in the calculation of NI.</td>
</tr>
<tr class="odd">
<td align="left">Areaind.Indicator</td>
<td align="left">vector</td>
<td align="left">character</td>
<td align="left"><span class="math inline">\(N.omr\)</span></td>
<td align="left">indicator names corresponding to the entries in Areaind.Name</td>
</tr>
<tr class="even">
<td align="left">Area.Name</td>
<td align="left">vector</td>
<td align="left">integer</td>
<td align="left">length(Area.Name)</td>
<td align="left">indicator area IDs, where each indicator area ID in Areaind.Name is repeated for each spatial unit it consists of</td>
</tr>
<tr class="odd">
<td align="left">Area.Municipality</td>
<td align="left">vector</td>
<td align="left">character</td>
<td align="left">length(Area.Name)</td>
<td align="left">names of basic spatial units corresponding to the entries in Area.Name</td>
</tr>
</tbody>
</table>
<p>Output</p>
<table>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Object type</th>
<th align="left">Mode</th>
<th align="left">Dim</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Weights.trof</td>
<td align="left">matrix</td>
<td align="left">double</td>
<td align="left"><em>N.kom x N.ind</em></td>
<td align="left"><span class="math inline">\(w^{p}\)</span>.</td>
</tr>
</tbody>
</table>
<div id="examples-3" class="section level3">
<h3>Examples:</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">munweights &lt;-<span class="st"> </span><span class="kw">munweights</span>(<span class="dt">Municipalities =</span> BSunits$Basicunit, <span class="dt">Indicators =</span> Indic$Indicator_name, 
    <span class="dt">FK_TrophicgroupID =</span> Indic$TrophicgroupID, <span class="dt">Key.indicators =</span> Indic$Key.indicators, 
    <span class="dt">Fidelity =</span> Indic$Fidelity, <span class="dt">Areaind.Name =</span> Indicator.area.ind$IndicatorareaID, 
    <span class="dt">Areaind.Indicator =</span> Indicator.area.ind$Indicator_name, <span class="dt">Area.Name =</span> Indicator.area$IndicatorareaID, 
    <span class="dt">Area.Municipality =</span> Indicator.area$Basicunit)

munweights[, <span class="dv">1</span>:<span class="dv">6</span>]</code></pre></div>
<pre><code>##            Ind 1      Ind 2      Ind 3      Ind 4      Ind 5      Ind 6
## Mun 1 0.00500000 0.05333333 0.04666667 0.00000000 0.02000000 0.00000000
## Mun 2 0.01082251 0.05333333 0.04666667 0.00000000 0.04329004 0.06666667
## Mun 3 0.00000000 0.06666667 0.05833333 0.03676471 0.03472222 0.00000000
## Mun 4 0.00000000 0.00000000 0.12500000 0.03676471 0.03472222 0.00000000</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rowSums</span>(munweights)</code></pre></div>
<pre><code>## Mun 1 Mun 2 Mun 3 Mun 4 
##     1     1     1     1</code></pre>
<p>If you want to ignore trophic groups in the calculation of <span class="math inline">\(w^{p}\)</span>, set all entries in FK_TrophicgroupID equal to each other. If you want to ignore the distinction between key- and non-key indicators, set Key.indicators to FALSE. If you want to ignore differences in fidelity, set all entries in Fidelity equal 1.0. If you want to give equal weights to all indicators observed in a communty, enter all three of these settings for FK_TrophicgroupID, Key.indicators and Fidelity.<br />
</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">munweights</span>(<span class="dt">Municipalities =</span> BSunits$Basicunit, <span class="dt">Indicators =</span> Indic$Indicator_name, 
    <span class="dt">FK_TrophicgroupID =</span> <span class="kw">rep</span>(<span class="dv">4</span>, <span class="kw">length</span>(Indic$TrophicgroupID)), <span class="dt">Key.indicators =</span> <span class="kw">rep</span>(F, 
        <span class="kw">length</span>(Indic$Key.indicators)), <span class="dt">Fidelity =</span> <span class="kw">rep</span>(<span class="dv">1</span>, <span class="kw">length</span>(Indic$Fidelity)), 
    <span class="dt">Areaind.Name =</span> Indicator.area.ind$IndicatorareaID, <span class="dt">Areaind.Indicator =</span> Indicator.area.ind$Indicator_name, 
    <span class="dt">Area.Name =</span> Indicator.area$IndicatorareaID, <span class="dt">Area.Municipality =</span> Indicator.area$Basicunit)[, 
    <span class="dv">1</span>:<span class="dv">6</span>]</code></pre></div>
<pre><code>##            Ind 1      Ind 2      Ind 3      Ind 4      Ind 5      Ind 6
## Mun 1 0.03846154 0.03846154 0.03846154 0.00000000 0.03846154 0.00000000
## Mun 2 0.07142857 0.07142857 0.07142857 0.00000000 0.07142857 0.07142857
## Mun 3 0.00000000 0.07142857 0.07142857 0.07142857 0.07142857 0.00000000
## Mun 4 0.00000000 0.00000000 0.07692308 0.07692308 0.07692308 0.00000000</code></pre>
<p></p>
</div>
</div>
<div id="nicalculation.fct" class="section level2">
<h2>NIcalculation.fct</h2>
<p>Function for calculating nsim draws of NI from nsim sets of (N.omr) scaled observations for (N.ind) indicators and corresponding areaweights, trophic weights and fidelity weights for a set of (N.kom) basic spatial units or a set of (N.reg) aggregated NI-areas each consisting of one or several basic spatial units.</p>
<p>Scaled indicatorobservations are calculated in scaleobs.fct, while area weights are calculated in areaweights.fct, and the product of trophic weights and fidelity weights in munweights.fct.</p>
<p>NI is calculated for a set of NI-areas, while scaled indicator observations, on the other hand, refer to indicator specific areas that may vary in geographical extent among indicators, and will in general not correspond to the NI-areas. Thus, NIcalculation.fct needs input about the spatial extent of each indicator area and NI-area.</p>
<p>Area weights should not be entered to NIcalculation.fct if NI is calculated for basic spatial units.</p>
<p>NIcalculate returns a matrix of nsim draws of NI for each NI-area (or basic spatial unit), of class NIresults.</p>
<p>Input arguments:</p>
<table>
<colgroup>
<col width="18%"></col>
<col width="15%"></col>
<col width="15%"></col>
<col width="17%"></col>
<col width="32%"></col>
</colgroup>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Object type</th>
<th align="left">Mode</th>
<th align="left">Dim</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Areaind.Name</td>
<td align="left">vector</td>
<td align="left">integer</td>
<td align="left"><span class="math inline">\(N.omr\)</span></td>
<td align="left">unique indicator area IDs</td>
</tr>
<tr class="even">
<td align="left">Areaind.Indicator</td>
<td align="left">vector</td>
<td align="left">character</td>
<td align="left"><span class="math inline">\(N.omr\)</span></td>
<td align="left">indicator names corresponding to the entries in Areaind.Name</td>
</tr>
<tr class="odd">
<td align="left">Area.Name</td>
<td align="left">vector</td>
<td align="left">integer</td>
<td align="left">length(Area.Name)</td>
<td align="left">indicator area IDs, where each indicator area ID is repeated for each basic spatial unit it consists of</td>
</tr>
<tr class="even">
<td align="left">Area.Municipality</td>
<td align="left">vector</td>
<td align="left">character</td>
<td align="left">length(Area.Name)</td>
<td align="left">vector of names of corresponding basic spatial units</td>
</tr>
<tr class="odd">
<td align="left">FK_OmraadeID</td>
<td align="left">vector</td>
<td align="left">integer</td>
<td align="left"><span class="math inline">\(N.omr\)</span></td>
<td align="left">indicator area IDs corresponding to the sequence of indicator observations in scaled.bootmat</td>
</tr>
<tr class="even">
<td align="left">nsim</td>
<td align="left">vector</td>
<td align="left">integer</td>
<td align="left"><span class="math inline">\(1\)</span></td>
<td align="left">number of draws (simulations) in the estimation of NI</td>
</tr>
<tr class="odd">
<td align="left">scaled.bootmat</td>
<td align="left">matrix</td>
<td align="left">double</td>
<td align="left"><em>N.omr x nsim</em></td>
<td align="left">nsim random draws of scaled indicator observations or nsim copies of scaled expected values</td>
</tr>
<tr class="even">
<td align="left">Weights.trof</td>
<td align="left">matrix</td>
<td align="left">double</td>
<td align="left"><em>N.kom x N.ind</em></td>
<td align="left">product of fidelity weights and trophic weights <span class="math inline">\(w^{p}\)</span></td>
</tr>
<tr class="odd">
<td align="left">Weights.reg.area</td>
<td align="left">array</td>
<td align="left">double</td>
<td align="left"><em>N.kom x N.ind x N.reg</em></td>
<td align="left">area weights <span class="math inline">\(w^{area}\)</span></td>
</tr>
</tbody>
</table>
<p>Output:</p>
<table>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Object type</th>
<th align="left">Mode</th>
<th align="left">Dim</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">NI</td>
<td align="left">NIresult, matrix</td>
<td align="left">double</td>
<td align="left"><em>(N.kom or N.reg) x nsim</em></td>
<td align="left">matrix of NI draws</td>
</tr>
</tbody>
</table>
</div>
<div id="summary.niresults" class="section level2">
<h2>summary.NIresults</h2>
<p>The summary function for NIresults provides point estimates of the Nature Index together with confidence intervals for a set of <span class="math inline">\(N.reg\)</span> basic spatial units or aggregated NI-areas from a <span class="math inline">\(N.reg x nsim\)</span> matrix of <span class="math inline">\(nsim\)</span> simulations of NI for each area.</p>
<p>As default parameters returns the median simulated value as the point estimate and the 0.025- and 0.975- quantiles as limits for the confidence interval.</p>
<p>Input arguments:</p>
<table>
<colgroup>
<col width="18%"></col>
<col width="15%"></col>
<col width="15%"></col>
<col width="17%"></col>
<col width="32%"></col>
</colgroup>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Object type</th>
<th align="left">Mode</th>
<th align="left">Dim</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">NI</td>
<td align="left">NIsummary</td>
<td align="left">double</td>
<td align="left"><em>(N.kom or N.reg) x nsim</em></td>
<td align="left">NI draws</td>
</tr>
<tr class="even">
<td align="left">kvantiler</td>
<td align="left">vector</td>
<td align="left">double</td>
<td align="left">3</td>
<td align="left">Quantiles used as basis for point estimate and limits of confidence interval.</td>
</tr>
</tbody>
</table>
<p>Output:</p>
<table>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Object type</th>
<th align="left">Mode</th>
<th align="left">Dim</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">NIest</td>
<td align="left">matrix</td>
<td align="left">double</td>
<td align="left"><em>(N.kom or N.reg) x 3</em></td>
<td align="left">Estimates of NI</td>
</tr>
</tbody>
</table>
<div id="examples-4" class="section level3">
<h3>Examples</h3>
<p>To estimate the Nature Index for the area “All area”, enter the areaweights stored in areaweights1 which was calculated above.<br />
</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(<span class="kw">NIcalculate</span>(<span class="dt">Areaind.Name =</span> Indicator.area.ind$IndicatorareaID, <span class="dt">Areaind.Indicator =</span> Indicator.area.ind$Indicator_name, 
    <span class="dt">Area.Name =</span> Indicator.area$IndicatorareaID, <span class="dt">Area.Municipality =</span> Indicator.area$Basicunit, 
    <span class="dt">FK_OmraadeID =</span> Observationsyear2$IndicatorareaID[Observationsyear2$ReferenceYearID !=<span class="st"> </span>
<span class="st">        </span><span class="dv">0</span>], <span class="dt">nsim =</span> <span class="dv">1000</span>, <span class="dt">scaled.bootmat =</span> scaled.bootmatyear2[Observationsyear2$ReferenceYearID !=<span class="st"> </span>
<span class="st">        </span><span class="dv">0</span>, ], <span class="dt">Weights.trof =</span> munweights, <span class="dt">Weights.reg.area =</span> areaweights1))</code></pre></div>
<pre><code>##              0.025       0.5     0.975
## All area 0.5655945 0.6872445 0.7765404
## attr(,&quot;class&quot;)
## [1] &quot;NIsummary&quot; &quot;matrix&quot;</code></pre>
<p>To estimate the Nature Index for the NI-areas “Part1” and “Part2”, weights stored in areaweights2.<br />
</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(<span class="kw">NIcalculate</span>(<span class="dt">Areaind.Name =</span> Indicator.area.ind$IndicatorareaID, <span class="dt">Areaind.Indicator =</span> Indicator.area.ind$Indicator_name, 
    <span class="dt">Area.Name =</span> Indicator.area$IndicatorareaID, <span class="dt">Area.Municipality =</span> Indicator.area$Basicunit, 
    <span class="dt">FK_OmraadeID =</span> Observationsyear2$IndicatorareaID[Observationsyear2$ReferenceYearID !=<span class="st"> </span>
<span class="st">        </span><span class="dv">0</span>], <span class="dt">nsim =</span> <span class="dv">1000</span>, <span class="dt">scaled.bootmat =</span> scaled.bootmatyear2[Observationsyear2$ReferenceYearID !=<span class="st"> </span>
<span class="st">        </span><span class="dv">0</span>, ], <span class="dt">Weights.trof =</span> munweights, <span class="dt">Weights.reg.area =</span> areaweights2))</code></pre></div>
<pre><code>##            0.025       0.5     0.975
## Part 1 0.6080190 0.6935618 0.7704158
## Part 2 0.4940039 0.6873745 0.8012796
## attr(,&quot;class&quot;)
## [1] &quot;NIsummary&quot; &quot;matrix&quot;</code></pre>
<p>To estimate the Nature Index for basic spatial units, do not enter area weights.<br />
</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(<span class="kw">NIcalculate</span>(<span class="dt">Areaind.Name =</span> Indicator.area.ind$IndicatorareaID, <span class="dt">Areaind.Indicator =</span> Indicator.area.ind$Indicator_name, 
    <span class="dt">Area.Name =</span> Indicator.area$IndicatorareaID, <span class="dt">Area.Municipality =</span> Indicator.area$Basicunit, 
    <span class="dt">FK_OmraadeID =</span> Observationsyear2$IndicatorareaID[Observationsyear2$ReferenceYearID !=<span class="st"> </span>
<span class="st">        </span><span class="dv">0</span>], <span class="dt">nsim =</span> <span class="dv">1000</span>, <span class="dt">scaled.bootmat =</span> scaled.bootmatyear2[Observationsyear2$ReferenceYearID !=<span class="st"> </span>
<span class="st">        </span><span class="dv">0</span>, ], <span class="dt">Weights.trof =</span> munweights))</code></pre></div>
<pre><code>##           0.025       0.5     0.975
## Mun 1 0.6107733 0.7235353 0.8134510
## Mun 2 0.4932455 0.6915602 0.8106823
## Mun 3 0.5047031 0.6284237 0.7424388
## Mun 4 0.4856354 0.6041666 0.7130334
## attr(,&quot;class&quot;)
## [1] &quot;NIsummary&quot; &quot;matrix&quot;</code></pre>
<p>To change to eg. a 90% confidence interval, specify nondefault values for kvantiler.<br />
</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(<span class="kw">NIcalculate</span>(<span class="dt">Areaind.Name =</span> Indicator.area.ind$IndicatorareaID, <span class="dt">Areaind.Indicator =</span> Indicator.area.ind$Indicator_name, 
    <span class="dt">Area.Name =</span> Indicator.area$IndicatorareaID, <span class="dt">Area.Municipality =</span> Indicator.area$Basicunit, 
    <span class="dt">FK_OmraadeID =</span> Observationsyear2$IndicatorareaID[Observationsyear2$ReferenceYearID !=<span class="st"> </span>
<span class="st">        </span><span class="dv">0</span>], <span class="dt">nsim =</span> <span class="dv">1000</span>, <span class="dt">scaled.bootmat =</span> scaled.bootmatyear2[Observationsyear2$ReferenceYearID !=<span class="st"> </span>
<span class="st">        </span><span class="dv">0</span>, ], <span class="dt">Weights.trof =</span> munweights))</code></pre></div>
<pre><code>##           0.025       0.5     0.975
## Mun 1 0.6107733 0.7235353 0.8134510
## Mun 2 0.4932455 0.6915602 0.8106823
## Mun 3 0.5047031 0.6284237 0.7424388
## Mun 4 0.4856354 0.6041666 0.7130334
## attr(,&quot;class&quot;)
## [1] &quot;NIsummary&quot; &quot;matrix&quot;</code></pre>
<p></p>
</div>
</div>
</div>
<div id="more-examples-of-calculations-based-on-the-test-data-set" class="section level1">
<h1>More examples of calculations based on the test data set</h1>
<div id="calculate-ni-for-basic-spatial-units-for-all-four-years." class="section level2">
<h2>Calculate NI for basic spatial units for all four years.</h2>
<p>In the test data set there are no missing indicator observations, i.e. indicator observations have been recorded in all indicator areas in each of the four years included. This means that weights used in the calculation of NI will be the same for all years.</p>
<p>In the example below, uncertainties in reference values are not accounted for.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Observations &lt;-<span class="st"> </span><span class="kw">data.frame</span>(Observations, <span class="kw">elicitate</span>(<span class="dt">expected.value =</span> Observations$Expected.value, 
    <span class="dt">lower =</span> Observations$Lower, <span class="dt">upper =</span> Observations$Upper)[, <span class="dv">1</span>:<span class="dv">3</span>])

years &lt;-<span class="st"> </span><span class="kw">unique</span>(Observations$ReferenceYearID[Observations$ReferenceYearID !=<span class="st"> </span>
<span class="st">    </span><span class="dv">0</span>])
Alt_DistID &lt;-<span class="st"> </span>Observations$FK_DistID
Alt_DistID[Observations$ReferenceYearID ==<span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> &quot;NoBoot&quot;</span>

bootmatall &lt;-<span class="st"> </span><span class="kw">samplebootmat</span>(<span class="dt">ValueID =</span> Observations$ValueID, <span class="dt">Value =</span> Observations$Expected.value, 
    <span class="dt">RefobsID =</span> Observations$ReferenceYearID, <span class="dt">DistID =</span> Alt_DistID, <span class="dt">mu =</span> Observations$mu, 
    <span class="dt">sig =</span> Observations$sig, <span class="dt">nsim =</span> <span class="dv">1000</span>)

scaled.bootmatall &lt;-<span class="st"> </span><span class="kw">scaleobs</span>(<span class="dt">ValueID =</span> Observations$ValueID, <span class="dt">FK_OmraadeID =</span> Observations$IndicatorareaID, 
    <span class="dt">FK_IndicatorID =</span> Observations$IndicatorID, <span class="dt">FK_RefAarID =</span> Observations$ReferenceYearID, 
    <span class="dt">nsim =</span> <span class="dv">1000</span>, <span class="dt">bootmat =</span> bootmatall, <span class="dt">ref.value.code =</span> <span class="dv">0</span>, <span class="dt">IndicatorID =</span> Indic$IndicatorID, 
    <span class="dt">FK_Scalingmodel =</span> Indic$Scalingmodel)

munweightsforall &lt;-<span class="st"> </span><span class="kw">munweights</span>(<span class="dt">Municipalities =</span> BSunits$Basicunit, <span class="dt">Indicators =</span> Indic$Indicator_name, 
    <span class="dt">FK_TrophicgroupID =</span> Indic$TrophicgroupID, <span class="dt">Key.indicators =</span> Indic$Key.indicators, 
    <span class="dt">Fidelity =</span> Indic$Fidelity, <span class="dt">Areaind.Name =</span> Indicator.area.ind$IndicatorareaID, 
    <span class="dt">Areaind.Indicator =</span> Indicator.area.ind$Indicator_name, <span class="dt">Area.Name =</span> Indicator.area$IndicatorareaID, 
    <span class="dt">Area.Municipality =</span> Indicator.area$Basicunit)

NIresult &lt;-<span class="st"> </span><span class="ot">NULL</span>

for (i in years) {
    
    scaled.bootmatyeari &lt;-<span class="st"> </span>scaled.bootmatall[Observations$ReferenceYearID ==<span class="st"> </span>
<span class="st">        </span>i, ]
    
    NIi &lt;-<span class="st"> </span><span class="kw">summary</span>(<span class="kw">NIcalculate</span>(<span class="dt">Areaind.Name =</span> Indicator.area.ind$IndicatorareaID, 
        <span class="dt">Areaind.Indicator =</span> Indicator.area.ind$Indicator_name, <span class="dt">Area.Name =</span> Indicator.area$IndicatorareaID, 
        <span class="dt">Area.Municipality =</span> Indicator.area$Basicunit, <span class="dt">FK_OmraadeID =</span> Observations$IndicatorareaID[Observations$ReferenceYearID ==<span class="st"> </span>
<span class="st">            </span>i], <span class="dt">nsim =</span> <span class="dv">1000</span>, <span class="dt">scaled.bootmat =</span> scaled.bootmatyeari, <span class="dt">Weights.trof =</span> munweightsforall))
    
    year &lt;-<span class="st"> </span><span class="kw">rep</span>(i, <span class="kw">dim</span>(NIi)[<span class="dv">1</span>])
    iresult &lt;-<span class="st"> </span><span class="kw">cbind</span>(year, NIi)
    NIresult &lt;-<span class="st"> </span><span class="kw">rbind</span>(NIresult, iresult)
    
}

NIresult</code></pre></div>
<pre><code>##       year     0.025       0.5     0.975
## Mun 1    2 0.6175711 0.7212758 0.8195663
## Mun 2    2 0.4872419 0.6976382 0.8036914
## Mun 3    2 0.5066912 0.6297537 0.7415362
## Mun 4    2 0.4800276 0.6062764 0.7137495
## Mun 1    3 0.5898815 0.6968421 0.7988453
## Mun 2    3 0.4480324 0.6317774 0.7701732
## Mun 3    3 0.4224513 0.5462133 0.6757069
## Mun 4    3 0.4717986 0.5982579 0.6923076
## Mun 1    4 0.6100243 0.7080655 0.8145071
## Mun 2    4 0.5152507 0.7017915 0.8201587
## Mun 3    4 0.4537474 0.5753417 0.7191170
## Mun 4    4 0.4674115 0.5581206 0.6796353
## Mun 1    8 0.5641513 0.6523417 0.7290440
## Mun 2    8 0.4750877 0.6487638 0.7832447
## Mun 3    8 0.4207004 0.5318247 0.6151073
## Mun 4    8 0.4584508 0.5089244 0.5781145</code></pre>
</div>
<div id="calculate-ni-with-uncertain-reference-values" class="section level2">
<h2>Calculate NI with uncertain reference values</h2>
<p>The same code as above, however without the assignment: Alt_DistID[Observations$ReferenceYearID==0] &lt;- “NoBoot”. The result is as follows:</p>
<pre><code>##       year     0.025       0.5     0.975
## Mun 1    2 0.6122497 0.7234588 0.8144133
## Mun 2    2 0.4978450 0.6910759 0.8117935
## Mun 3    2 0.4991543 0.6287367 0.7448648
## Mun 4    2 0.4806024 0.6112848 0.7227254
## Mun 1    3 0.5894103 0.6945810 0.7892631
## Mun 2    3 0.4329325 0.6271834 0.7540485
## Mun 3    3 0.4216633 0.5521915 0.6821252
## Mun 4    3 0.4756354 0.6009975 0.6918377
## Mun 1    4 0.5988491 0.7042200 0.8137541
## Mun 2    4 0.5013101 0.6994893 0.8151855
## Mun 3    4 0.4581524 0.5733401 0.7190243
## Mun 4    4 0.4658278 0.5538979 0.6827743
## Mun 1    8 0.5678447 0.6510382 0.7326392
## Mun 2    8 0.4644855 0.6512624 0.7788841
## Mun 3    8 0.4196257 0.5340709 0.6175399
## Mun 4    8 0.4565662 0.5109110 0.5829758</code></pre>
<p><br />
Note, however, that several reference values in the test data set are entered with zreo uncertainty.</p>
</div>
<div id="estimate-the-effect-of-uncertainty-in-reference-values" class="section level2">
<h2>Estimate the effect of uncertainty in reference values</h2>
<p>One may want to estimate the uncertainty in the calculated NI values that results from uncertainty in the reference values only.</p>
<p>The code for doing this is again the same as above, however this time the assignment<br />
Alt_DistID[Observations$ReferenceYearID==0] &lt;- “NoBoot”<br />
should be replaced with<br />
Alt_DistID[Observations$ReferenceYearID!=0] &lt;- “NoBoot”<br />
</p>
<pre><code>##       year     0.025       0.5     0.975
## Mun 1    2 0.7681888 0.7681888 0.7681888
## Mun 2    2 0.7376662 0.7376662 0.7376662
## Mun 3    2 0.6423352 0.6423352 0.6423352
## Mun 4    2 0.6173134 0.6173134 0.6173134
## Mun 1    3 0.7252688 0.7252688 0.7252688
## Mun 2    3 0.6553767 0.6553767 0.6553767
## Mun 3    3 0.5672605 0.5672605 0.5672605
## Mun 4    3 0.6336953 0.6336953 0.6336953
## Mun 1    4 0.7296070 0.7296070 0.7296070
## Mun 2    4 0.7368540 0.7368540 0.7368540
## Mun 3    4 0.5965567 0.5965567 0.5965567
## Mun 4    4 0.5726695 0.5726695 0.5726695
## Mun 1    8 0.6574743 0.6574743 0.6574743
## Mun 2    8 0.7100785 0.7100785 0.7100785
## Mun 3    8 0.5615443 0.5615443 0.5615443
## Mun 4    8 0.5155545 0.5155545 0.5155545</code></pre>
<p>The result illustrates what was noted above, that many reference values in the test data set lack estimates of uncertainty.</p>
</div>
<div id="calculate-ni-without-uncertainties" class="section level2">
<h2>Calculate NI without uncertainties</h2>
<p>Again, the same code as above, however this time all entries in Alt_DistID are set to “NoBoot”.</p>
<pre><code>##       year     0.025       0.5     0.975
## Mun 1    2 0.7681888 0.7681888 0.7681888
## Mun 2    2 0.7376662 0.7376662 0.7376662
## Mun 3    2 0.6423352 0.6423352 0.6423352
## Mun 4    2 0.6173134 0.6173134 0.6173134
## Mun 1    3 0.7252688 0.7252688 0.7252688
## Mun 2    3 0.6553767 0.6553767 0.6553767
## Mun 3    3 0.5672605 0.5672605 0.5672605
## Mun 4    3 0.6336953 0.6336953 0.6336953
## Mun 1    4 0.7296070 0.7296070 0.7296070
## Mun 2    4 0.7368540 0.7368540 0.7368540
## Mun 3    4 0.5965567 0.5965567 0.5965567
## Mun 4    4 0.5726695 0.5726695 0.5726695
## Mun 1    8 0.6574743 0.6574743 0.6574743
## Mun 2    8 0.7100785 0.7100785 0.7100785
## Mun 3    8 0.5615443 0.5615443 0.5615443
## Mun 4    8 0.5155545 0.5155545 0.5155545</code></pre>
<p>The difference between NI calculated with uncertainities and NI calculated without, is an estimate of the socalled location displacement mentioned on page 37 in Pedersen <em>et al.</em> (2016)<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> and discussed in debth in Pedersen and Skarpaas (2012)<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</p>
<pre><code>##       year       0.025          0.5      0.975
## Mun 1    0 -0.15061774 -0.046912973 0.05137748
## Mun 2    0 -0.25042429 -0.040027967 0.06602526
## Mun 3    0 -0.13564393 -0.012581469 0.09920103
## Mun 4    0 -0.13728582 -0.011036987 0.09643617
## Mun 1    0 -0.13538728 -0.028426693 0.07357644
## Mun 2    0 -0.20734433 -0.023599311 0.11479645
## Mun 3    0 -0.14480921 -0.021047232 0.10844634
## Mun 4    0 -0.16189674 -0.035437383 0.05861227
## Mun 1    0 -0.11958273 -0.021541560 0.08490005
## Mun 2    0 -0.22160333 -0.035062478 0.08330471
## Mun 3    0 -0.14280929 -0.021214954 0.12256030
## Mun 4    0 -0.10525802 -0.014548940 0.10696580
## Mun 1    0 -0.09332300 -0.005132655 0.07156967
## Mun 2    0 -0.23499085 -0.061314724 0.07316622
## Mun 3    0 -0.14084390 -0.029719585 0.05356307
## Mun 4    0 -0.05710371 -0.006630069 0.06256004</code></pre>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Pedersen, B., Nybø, S., Sæther, S. A. (eds.) 2016. Nature Index for Norway 2015. Ecological framework, computational methods, database and information systems – NINA Report 1226. 84 pp.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Pedersen, B., Nybø, S., Sæther, S. A. (eds.) 2016. Nature Index for Norway 2015. Ecological framework, computational methods, database and information systems – NINA Report 1226. 84 pp.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Pedersen, B., Skarpaas, O. 2012. Statistiske egenskaper til Naturindeks for Norge. Usikkerhet i datagrunnlaget og sensitivitet. - NINA Rapport 797, Trondheim. 55 pp. (In Norwegian)<a href="#fnref3">↩</a></p></li>
</ol>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
